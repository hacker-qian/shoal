diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/crc.c ./crc.c
--- /home/skaestle/Desktop/shl-sc/streamcluster/crc.c	1970-01-01 01:00:00.000000000 +0100
+++ ./crc.c	2014-07-21 10:47:32.417694098 +0200
@@ -0,0 +1,100 @@
+/**
+ * \file crc.c
+ * Functions and types for CRC checks.
+ *
+ * Generated on Wed Jul  9 21:15:38 2014,
+ * by pycrc v0.8.1, http://www.tty1.net/pycrc/
+ * using the configuration:
+ *    Width        = 16
+ *    Poly         = 0x8005
+ *    XorIn        = 0x0000
+ *    ReflectIn    = True
+ *    XorOut       = 0x0000
+ *    ReflectOut   = True
+ *    Algorithm    = table-driven
+ *****************************************************************************/
+#include "crc.h"     /* include the header file generated with pycrc */
+#include <stdlib.h>
+#include <stdint.h>
+
+/**
+ * Static table used for the table_driven implementation.
+ *****************************************************************************/
+static const crc_t crc_table[256] = {
+    0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
+    0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
+    0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
+    0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
+    0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
+    0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
+    0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
+    0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
+    0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
+    0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
+    0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
+    0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
+    0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
+    0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
+    0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
+    0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
+    0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
+    0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
+    0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
+    0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
+    0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
+    0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
+    0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
+    0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
+    0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
+    0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
+    0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
+    0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
+    0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
+    0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
+    0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
+    0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
+};
+
+/**
+ * Reflect all bits of a \a data word of \a data_len bytes.
+ *
+ * \param data         The data word to be reflected.
+ * \param data_len     The width of \a data expressed in number of bits.
+ * \return             The reflected data.
+ *****************************************************************************/
+crc_t crc_reflect(crc_t data, size_t data_len)
+{
+    unsigned int i;
+    crc_t ret;
+
+    ret = data & 0x01;
+    for (i = 1; i < data_len; i++) {
+        data >>= 1;
+        ret = (ret << 1) | (data & 0x01);
+    }
+    return ret;
+}
+
+
+/**
+ * Update the crc value with new data.
+ *
+ * \param crc      The current crc value.
+ * \param data     Pointer to a buffer of \a data_len bytes.
+ * \param data_len Number of bytes in the \a data buffer.
+ * \return         The updated crc value.
+ *****************************************************************************/
+crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len)
+{
+    unsigned int tbl_idx;
+
+    while (data_len--) {
+        tbl_idx = (crc ^ *data) & 0xff;
+        crc = (crc_table[tbl_idx] ^ (crc >> 8)) & 0xffff;
+
+        data++;
+    }
+    return crc & 0xffff;
+}
+
+
diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/crc.h ./crc.h
--- /home/skaestle/Desktop/shl-sc/streamcluster/crc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./crc.h	2014-07-21 10:47:32.417694098 +0200
@@ -0,0 +1,89 @@
+/**
+ * \file crc.h
+ * Functions and types for CRC checks.
+ *
+ * Generated on Wed Jul  9 21:15:42 2014,
+ * by pycrc v0.8.1, http://www.tty1.net/pycrc/
+ * using the configuration:
+ *    Width        = 16
+ *    Poly         = 0x8005
+ *    XorIn        = 0x0000
+ *    ReflectIn    = True
+ *    XorOut       = 0x0000
+ *    ReflectOut   = True
+ *    Algorithm    = table-driven
+ *****************************************************************************/
+#ifndef __CRC_H__
+#define __CRC_H__
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * The definition of the used algorithm.
+ *****************************************************************************/
+#define CRC_ALGO_TABLE_DRIVEN 1
+
+
+/**
+ * The type of the CRC values.
+ *
+ * This type must be big enough to contain at least 16 bits.
+ *****************************************************************************/
+typedef uint_fast16_t crc_t;
+
+
+/**
+ * Reflect all bits of a \a data word of \a data_len bytes.
+ *
+ * \param data         The data word to be reflected.
+ * \param data_len     The width of \a data expressed in number of bits.
+ * \return             The reflected data.
+ *****************************************************************************/
+crc_t crc_reflect(crc_t data, size_t data_len);
+
+
+/**
+ * Calculate the initial crc value.
+ *
+ * \return     The initial crc value.
+ *****************************************************************************/
+static inline crc_t crc_init(void)
+{
+    return 0x0000;
+}
+
+
+/**
+ * Update the crc value with new data.
+ *
+ * \param crc      The current crc value.
+ * \param data     Pointer to a buffer of \a data_len bytes.
+ * \param data_len Number of bytes in the \a data buffer.
+ * \return         The updated crc value.
+ *****************************************************************************/
+crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len);
+
+
+/**
+ * Calculate the final crc value.
+ *
+ * \param crc  The current crc value.
+ * \return     The final crc value.
+ *****************************************************************************/
+static inline crc_t crc_finalize(crc_t crc)
+{
+    return crc ^ 0x0000;
+}
+
+
+#ifdef __cplusplus
+}           /* closing brace for extern "C" */
+#endif
+
+#endif      /* __CRC_H__ */
diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/Makefile ./Makefile
--- /home/skaestle/Desktop/shl-sc/streamcluster/Makefile	2015-06-23 11:17:22.546771791 +0200
+++ ./Makefile	2015-06-23 11:20:53.525624020 +0200
@@ -2,30 +2,81 @@
 
 PREFIX=${PARSECDIR}/pkgs/kernels/streamcluster/inst/${PARSECPLAT}
 
 TARGET=streamcluster
 OBJS=streamcluster.o
 
-ifdef version
-  ifeq "$(version)" "pthreads"
-    CXXFLAGS :=	$(CXXFLAGS) -DENABLE_THREADS -pthread
-    OBJS += parsec_barrier.o
-  endif
-  ifeq "$(version)" "tbb"
-    CXXFLAGS := $(CXXFLAGS) -DTBB_VERSION
-    LIBS := $(LIBS) -ltbb
-  endif
+CXXFLAGS := $(CXXFLAGS) -DENABLE_THREADS -pthread
+OBJS += parsec_barrier.o crc.o
+
+GIT_VERSION := $(shell git describe --abbrev=4 --dirty --always)
+
+#BUILDTYPE := debug
+BUILDTYPE := release
+
+all: streamcluster
+
+# --------------------------------------------------
+# Shoal integration >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+# Path informations
+ROOT := $(shell pwd)
+BASE := $(ROOT)/../libshoal/
+SHOAL := $(BASE)/shoal/
+
+OBJS += $(SHOAL)/src/misc.o $(SHOAL)/src/linux.o $(SHOAL)/src/shl.o
+
+INC := \
+	-I$(SHOAL)/inc
+
+LIB := \
+	-lnuma \
+	-lpapi \
+	-lpfm \
+	-L$(SHOAL) -lshl \
+	-L/usr/lib/x86_64-linux-gnu/ -llua5.2 \
+       -lm -ldl
+
+ifeq ($(BUILDTYPE),debug)
+	CXXFLAGS +=-g -O0 -pg -DSHL_DEBUG
+else
+	CXXFLAGS += -O3
 endif
 
-all: $(OBJS)
+CXXFLAGS += -std=gnu++0x
+
+CXXFLAGS += $(INC) -DVERSION=\"$(GIT_VERSION)\" -fopenmp
+LIBS += $(LIB)
+
+# Helpers to build libshoal
+# ------------------------------
+
+LIBSHOAL := $(SHOAL)/libshl.so
+
+# Recursively build libshoal
+.PHONY: $(LIBSHOAL)
+$(LIBSHOAL):
+	$(MAKE) -C $(SHOAL) BUILDTYPE=$(BUILDTYPE)
+
+sk_clean:
+	$(MAKE) -C $(SHOAL) clean
+
+# END Shoal integration <<<<<<<<<<<<<<<<<<<<<<<<<<<<
+# --------------------------------------------------
+
+.PHONY: streamcluster
+streamcluster: $(LIBSHOAL) | $(OBJS)
 	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(OBJS) $(LIBS) -o $(TARGET)
 
 %.o : %.cpp
 	$(CXX) $(CXXFLAGS) -c $<
 
+%.o : %.c
+	$(CXX) $(CXXFLAGS) -c $< -o $@
+
 clean:
 	rm -f *.o $(TARGET)
+	$(MAKE) -C $(SHLPREFIX) clean
 
 install:
 	mkdir -p $(PREFIX)/bin
 	cp -f $(TARGET) $(PREFIX)/bin/$(TARGET)
-
diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/streamcluster.cpp ./streamcluster.cpp
--- /home/skaestle/Desktop/shl-sc/streamcluster/streamcluster.cpp	2015-06-23 11:17:22.546771791 +0200
+++ ./streamcluster.cpp	2015-06-23 11:20:53.529624076 +0200
@@ -15,21 +15,64 @@
 #include <math.h>
 #include <sys/resource.h>
 #include <limits.h>
+#include <shl.h>
+
+// --------------------------------------------------
+// CONFIGURATION
+// --------------------------------------------------
+
+// Write randomly generated coordiantes to file
+//#define SK_WRITE_INPUT
+
+// Calculate and print CRC on coordinates
+// These are either read from file or generated automatically
+#define SK_CRC_INPUT
+
+// Caculate the CRC of centers and blocks for every chunk + end
+#define SK_CRC_RUNTIME
+
+// Bind threads to cores
+#define SK_BIND
+
+// Replicate arrays
+#define SC_REPLICATION
+
+// Use huge pages for arrays (need machine support)
+//#define SC_HUGEPAGE
+
+// --------------------------------------------------
+// STATE
+// --------------------------------------------------
+
+// Per thread:
+
+// We need an "accessor" for the block array
+#ifdef SC_REPLICATION
+// Thread-local accessor used in SK_P macro
+__thread float *sk_block_a;
+// Pointer to all replicas
+float **sk_block_accessors;
+// We use *_org to point to the original arrays
+float *sk_center_org;
+float *sk_block_org;
+#else
+float *sk_block_a;
+float *sk_center_a;
+#endif
+
+// --------------------------------------------------
+// --------------------------------------------------
 
 #ifdef ENABLE_THREADS
 #include <pthread.h>
 #include "parsec_barrier.hpp"
+
 #endif
 
-#ifdef TBB_VERSION
-#define TBB_STEALER (tbb::task_scheduler_init::occ_stealer)
-#define NUM_DIVISIONS (nproc)
-#include "tbb/task_scheduler_init.h"
-#include "tbb/blocked_range.h"
-#include "tbb/parallel_for.h"
-#include "tbb/parallel_reduce.h"
-#include "tbb/cache_aligned_allocator.h"
-using namespace tbb;
+#ifdef SK_CRC_INPUT
+extern "C" {
+#include "crc.h"
+}
 #endif
 
 #ifdef ENABLE_PARSEC_HOOKS
@@ -47,24 +90,25 @@ using namespace std;
 
 /* higher ITER --> more likely to get correct # of centers */
 /* higher ITER also scales the running time almost linearly */
-#define ITER 3 // iterate ITER* k log k times; ITER >= 1
+#define ITER 10 // iterate ITER* k log k times; ITER >= 1
 
 #define CACHE_LINE 32 // cache line in byte
 
 /* this structure represents a point */
 /* these will be passed around to avoid copying coordinates */
 typedef struct {
-  float weight;
-  float *coord;
-  long assign;  /* number of point where this one is assigned */
-  float cost;  /* cost of that assignment, weight*distance */
+    float weight;
+    float *coord;
+    uintptr_t coord_idx;
+    long assign;  /* number of point where this one is assigned */
+    float cost;  /* cost of that assignment, weight*distance */
 } Point;
 
 /* this is the array of points */
 typedef struct {
-  long num; /* number of points; may not be N if this is a sample */
-  int dim;  /* dimensionality */
-  Point *p; /* the array itself */
+    long num; /* number of points; may not be N if this is a sample */
+    int dim;  /* dimensionality */
+    Point *p; /* the array itself */
 } Points;
 
 static bool *switch_membership; //whether to switch membership in pgain
@@ -74,1095 +118,429 @@ static int* center_table; //index table
 static int nproc; //# of threads
 
 
-#ifdef TBB_VERSION
-tbb::cache_aligned_allocator<float> memoryFloat;
-tbb::cache_aligned_allocator<Point> memoryPoint;
-tbb::cache_aligned_allocator<long> memoryLong;
-tbb::cache_aligned_allocator<int> memoryInt;
-tbb::cache_aligned_allocator<bool> memoryBool;
-#endif
-
-
 float dist(Point p1, Point p2, int dim);
 
-
-#ifdef TBB_VERSION
-struct HizReduction {
-private:
-  double hiz;
-public:
-  Points *points;
-  HizReduction(Points *points_): hiz(0),points(points_){}
-  HizReduction( HizReduction &d, tbb::split){hiz=0; points = d.points;}
-
-  void operator()(const tbb::blocked_range<int>& range) {
-    double myhiz = 0;
-    long ptDimension = points->dim;
-    int begin = range.begin();
-    int end = range.end();
-    
-    for(int kk=begin; kk!=end; kk++) {
-      myhiz += dist(points->p[kk], points->p[0],
-			 ptDimension)*points->p[kk].weight;
-    }
-    hiz += myhiz;
-  }
-
-  void join(HizReduction &d){hiz += d.getHiz(); /*fprintf(stderr,"reducing: %lf\n",hiz);*/}
-  double getHiz(){return hiz;}
-
-};
-
-
-struct CenterCreate {
-  Points *points;
-  CenterCreate(Points *p): points(p){}
-  void operator()(const tbb::blocked_range<int>&range) const {
-    int begin = range.begin();
-    int end = range.end();
-    
-     for( int k = begin; k!=end; k++ )    {
-       float distance = dist(points->p[k],points->p[0],points->dim);
-       points->p[k].cost = distance * points->p[k].weight;
-       points->p[k].assign=0;
-     } 
-  }
-
-};
-
-
-
-struct CenterOpen {
-private:
-  double total_cost;
-public:
-  Points *points;
-  int i;
-  int type; /*type=0: compute. type=1: reduction */
-  CenterOpen(Points *p):points(p),total_cost(0),type(0){}
-  CenterOpen(CenterOpen &rhs, tbb::split) 
-  {
-    total_cost = 0; 
-    points = rhs.points;
-    i = rhs.i;
-    type = rhs.type;
-  }
-
-  void operator()(const tbb::blocked_range<int> &range) {
-    int begin = range.begin();
-    int end = range.end();
-
-    if(type) {
-      double local_total = 0.0;
-      for(int k = begin; k!=end; k++ )  
-	local_total+=points->p[k].cost;
-      total_cost += local_total;
-    }
-    else {
-      for(int k = begin; k!=end; k++ )  {
-	float distance = dist(points->p[i],points->p[k],points->dim);
-	if( i && distance*points->p[k].weight < points->p[k].cost )  {
-	  points->p[k].cost = distance * points->p[k].weight;
-	  points->p[k].assign=i;
-	}
-      }
-    }
-    
-  }
-
-
-  void join(CenterOpen &lhs){total_cost+=lhs.getTotalCost();}
-  double getTotalCost(){return total_cost;}
-
-};
-
-
-
-class CenterTableCount: public tbb::task{
-private:
-  Points *points;
-  double *work_mem;
-  int stride;
-  int pid;
-public:
-  CenterTableCount(int id, int s, Points *p, double *mem):
-    pid(id), stride(s), points(p),work_mem(mem){}
-
-  task *execute() {
-    int count = 0;
-    long bsize = points->num/((NUM_DIVISIONS));
-    long k1 = bsize * pid;
-    long k2 = k1 + bsize;
-
-    if( pid == (NUM_DIVISIONS)-1 ) 
-      k2 = points->num;
-
-    /* fprintf(stderr,"\t[CenterTableCount]: pid=%d stride=%d from %d to %d\n",
-       pid, stride, k1, k2); */
-
-    for( int i = k1; i < k2; i++ ) {
-      if( is_center[i] ) {
-	center_table[i] = count++;
-      }
-    }
-
-    work_mem[pid*stride] = count;
-    //fprintf(stderr,"PID %d done!\n",pid);
-    return NULL;
-  }
-
-};
-
-
-class CenterTableCountTask: public tbb::task {
-  int is_continuation;
-  Points *points;
-  double *work_mem;
-  int stride;
-public:
-  CenterTableCountTask(int s, Points *p, double *mem):
-    stride(s), points(p), work_mem(mem), is_continuation(0){} 
-
-  task *execute() {
-    tbb::task_list list;
-    int p;
-    
-    if(!is_continuation) {
-      recycle_as_continuation();
-      set_ref_count(NUM_DIVISIONS);
-
-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
-	  list.push_back( *new( allocate_child() ) CenterTableCount(p, stride, points, work_mem));
-      CenterTableCount &me = *new( allocate_child() ) CenterTableCount(0, stride, points, work_mem);
-      spawn(list);
-      is_continuation = 1;
-      
-      return &me;
-
-    }else {
-      /* continuation part */
-      int accum = 0;
-      for( int p = 0; p < (NUM_DIVISIONS); p++ ) {
-	int tmp = (int)work_mem[p*stride];
-	work_mem[p*stride] = accum;
-	accum += tmp;
-      }
-      //fprintf(stderr,"Accum = %d\n",accum);
-      return NULL;
-    }
-  }
-};
-
-
-class FixCenter: public tbb::task {
-  Points *points;
-  double *work_mem;
-  int pid;
-  int stride;
-public:
-  FixCenter(int id, int s, Points *p, double *mem):
-    pid(id),stride(s),points(p),work_mem(mem){}
-  task *execute(){
-#ifdef SERIAL_FIXCENTER
-    long k1 = 0;
-    long k2 = points->num;
-#else    
-    long bsize = points->num/((NUM_DIVISIONS));
-    long k1 = bsize * pid;
-    long k2 = k1 + bsize;
-    if( pid == (NUM_DIVISIONS)-1 ) k2 = points->num;
-#endif
-    /*fprintf(stderr,"\t[FixCenter]: pid=%d stride=%d from %d to %d is_center=0x%08x\n",
-      pid, stride, k1, k2,(int)is_center);  */
-    
-    for( int i = k1; i < k2; i++ ) {
-      if( is_center[i] ) {
-	center_table[i] += (int)work_mem[pid*stride];
-	//fprintf(stderr,"\tcenter_table[%d] = %d\n",i,center_table[i]);
-      }
-
-    }
-      //fprintf(stderr,"PID %d done!\n",pid);
-    return NULL;
-
-  }
-};
-
-class FixCenterTask: public tbb::task {
-  bool is_continuation;
-  Points *points;
-  double *work_mem;
-  int stride;
-public:
-  FixCenterTask(int s, Points *p, double *mem):
-    stride(s), points(p), work_mem(mem), is_continuation(false){} 
-
-  task *execute() {
-    tbb::task_list list;
-    int p;
-    if(!is_continuation) {
-      recycle_as_continuation();
-      set_ref_count(NUM_DIVISIONS);
-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
-	  list.push_back( *new( allocate_child() ) FixCenter(p, stride, points, work_mem));
-      spawn(list);
-      FixCenter &me = *new (allocate_child()) FixCenter(0, stride, points, work_mem);
-      is_continuation = true;
-      return &me;
-    }else {
-      /* coninuation */
-      return NULL;
-    }
-  }
-};
-
-
-class LowerCost: public tbb::task {
-  Points *points;
-  double *work_mem;
-  long x;
-  int K;
-  int pid;
-  int stride;
-public:
-  LowerCost(int id, int s, Points *p, long x_, double *mem, int k): 
-    pid(id), stride(s), points(p), work_mem(mem), K(k), x(x_){}
-  task *execute() {
-
-    //my *lower* fields
-    double* lower = &work_mem[pid*stride];
-    double local_cost_of_opening_x = 0;
-    long bsize = points->num/((NUM_DIVISIONS)); //points->num/1;//((NUM_DIVISIONS));
-    long k1 = bsize * pid;
-    long k2 = k1 + bsize;
-    int i;
-
-    if( pid == (NUM_DIVISIONS)-1 ) 
-      k2 = points->num;
-
-
-    /*fprintf(stderr,"\t[LowerCost]: pid=%d stride=%d from %d to %d\n",
-      pid, stride, k1, k2);  */
-    
-    double *cost_of_opening_x = &work_mem[pid*stride + K+1];
-
-    for ( i = k1; i < k2; i++ ) {
-      float x_cost = dist(points->p[i], points->p[x], points->dim) 
-	* points->p[i].weight;
-      float current_cost = points->p[i].cost;
-
-      //fprintf(stderr,"\t (x_cost=%lf < current_cost=%lf)\n",x_cost, current_cost);
-      if ( x_cost < current_cost ) {
-
-	// point i would save cost just by switching to x
-	// (note that i cannot be a median, 
-	// or else dist(p[i], p[x]) would be 0)
-	
-	switch_membership[i] = 1;
-	local_cost_of_opening_x += x_cost - current_cost;
-	
-      } else {
-	
-	// cost of assigning i to x is at least current assignment cost of i
-	
-	// consider the savings that i's **current** median would realize
-	// if we reassigned that median and all its members to x;
-	// note we've already accounted for the fact that the median
-	// would save z by closing; now we have to subtract from the savings
-	// the extra cost of reassigning that median and its members 
-	int assign = points->p[i].assign;
-	lower[center_table[assign]] += current_cost - x_cost;
-	//fprintf(stderr,"Lower[%d]=%lf\n",center_table[assign], lower[center_table[assign]]);
-      }
-    }
-    
-    *cost_of_opening_x = local_cost_of_opening_x;
-    return NULL;
-  }
-  
-  
-};
-  
-class LowerCostTask: public tbb::task {
-  bool is_continuation;
-  Points *points;
-  double *work_mem;
-  int K;
-  long x;
-  int stride;
-public:
-  LowerCostTask(int s, Points *p, long x_, double *mem, int k): 
-    stride(s), points(p), work_mem(mem), K(k), x(x_), is_continuation(false){}
-
-  task *execute() {
-    tbb::task_list list;
-    int p;
-    if(!is_continuation) {
-      recycle_as_continuation();
-      set_ref_count(NUM_DIVISIONS);
-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
-	  list.push_back( *new( allocate_child() )  LowerCost(p, stride, points, x, work_mem, K));
-      spawn(list);
-      LowerCost &me = *new (allocate_child())  LowerCost(0, stride, points, x, work_mem, K);
-      is_continuation = true;
-      return &me;
-    }else {
-      /* continuation */
-      return NULL;
-    }
-  }
-};
-
-
-
-
-class CenterClose: public tbb::task {
-  Points *points;
-  double *work_mem;
-  double *number_of_centers_to_close;
-  double z;
-  int pid, stride;
-  int K;
-
-public:
-  CenterClose(int id, int s, Points *p, double *mem, int k, double z_): 
-    pid(id),stride(s),points(p),work_mem(mem),K(k), z(z_){}
-
-  task *execute() {
-    double* gl_lower = &work_mem[(NUM_DIVISIONS)*stride];
-    double *cost_of_opening_x;
-    int local_number_of_centers_to_close = 0;
-    long bsize = points->num/((NUM_DIVISIONS)); //
-    long k1 = bsize * pid;
-    long k2 = k1 + bsize;
-
-    if( pid == (NUM_DIVISIONS)-1 ) 
-      k2 = points->num;
-
-    /*fprintf(stderr,"\t[CenterClose]: pid=%d stride=%d from %d to %d\n",
-      pid, stride, k1, k2); */
-
-    number_of_centers_to_close = &work_mem[pid*stride + K];
-    cost_of_opening_x = &work_mem[pid*stride + K+1];
-    
-      for ( int i = k1; i < k2; i++ ) {
-	if( is_center[i] ) {
-	  double low = z;
-	  //aggregate from all threads
-	  for( int p = 0; p < (NUM_DIVISIONS); p++ ) {
-	    low += work_mem[center_table[i]+p*stride];
-	  }
-	  gl_lower[center_table[i]] = low;
-	  if ( low > 0 ) {
-	    // i is a median, and
-	    // if we were to open x (which we still may not) we'd close i
-	    
-	    // note, we'll ignore the following quantity unless we do open x
-	    ++local_number_of_centers_to_close;  
-	    *cost_of_opening_x -= low;
-	  }
-	}
-      }
-      *number_of_centers_to_close = (double)local_number_of_centers_to_close;
-      return NULL;
-  }
-
-};
-
-
-class CenterCloseTask: public tbb::task {
-  bool is_continuation;
-  Points *points;
-  double *work_mem;
-  int stride;
-  double z;
-  int K;
-public:
-  CenterCloseTask(int s, Points *p, double *mem, int k, double z_): 
-    stride(s),points(p),work_mem(mem),K(k), z(z_), is_continuation(false){}
-
-  task *execute() {
-    tbb::task_list list;
-    int p;
-    if(!is_continuation) {
-      recycle_as_continuation();
-      set_ref_count(NUM_DIVISIONS);
-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
-	list.push_back( *new( allocate_child() )  CenterClose(p, stride, points, work_mem, K, z));
-      spawn(list);
-      CenterClose &me = *new (allocate_child())  CenterClose(0, stride, points, work_mem, K, z);
-      is_continuation = true;
-      return &me;
-    }else {
-      /* coninuation */
-
-
-      return NULL;
-    }
-  }
-};
-
-
-
-class SaveMoney: public tbb::task{
-  Points *points;
-  double *work_mem;
-  long x;
-  int pid, stride;
-public:
-  SaveMoney(int id, int s, Points *p, long x_, double *mem): 
-    pid(id), stride(s), points(p), x(x_), work_mem(mem){}
-  task *execute() {
-    double* gl_lower = &work_mem[(NUM_DIVISIONS)*stride];
-    long bsize = points->num/((NUM_DIVISIONS));//points->num/1;//((NUM_DIVISIONS));
-    long k1 = bsize * pid;
-    long k2 = k1 + bsize;
-    int i;
-    
-    if( pid == (NUM_DIVISIONS)-1 ) 
-      k2 = points->num;
-
-    /*fprintf(stderr,"\t[SaveMoney]: pid=%d stride=%d from %d to %d\n",
-      pid, stride, k1, k2);   */
-    
-
-    //  we'd save money by opening x; we'll do it
-    for ( int i = k1; i < k2; i++ ) {
-      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;
-      if ( switch_membership[i] || close_center ) {
-	// Either i's median (which may be i itself) is closing,
-	// or i is closer to x than to its current median
-	points->p[i].cost = points->p[i].weight *
-	  dist(points->p[i], points->p[x], points->dim);
-	points->p[i].assign = x;
-	//fprintf(stderr,"\t[SaveMoney] %d: cost %lf, x=%d\n",i,points->p[i].cost, x);
-      }
-    }
-    for( int i = k1; i < k2; i++ ) {
-      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {
-	is_center[i] = false;
-      }
-    }
-    if( x >= k1 && x < k2 ) {
-      //fprintf(stderr,"\t-->is_center[%d]=true!\n",x);
-      is_center[x] = true;
-    }
-
-
-    return NULL;
-  }
-};
-
-
-class SaveMoneyTask: public tbb::task {
-  bool is_continuation;
-  Points *points;
-  long x;
-  double* work_mem;
-  int stride;
-
-public:
-  SaveMoneyTask(int s, Points *p, long x_, double *mem): 
-    stride(s), points(p), x(x_), work_mem(mem) ,is_continuation(false){}
-
-
-  task *execute() {
-    tbb::task_list list;
-    int p;
-    if(!is_continuation) {
-      recycle_as_continuation();
-      set_ref_count(NUM_DIVISIONS);
-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
-	list.push_back( *new( allocate_child() )  SaveMoney(p, stride, points, x, work_mem));
-      spawn(list);
-      SaveMoney &me = *new (allocate_child())  SaveMoney(0, stride, points, x, work_mem);
-      is_continuation = true;
-      return &me;
-    }else {
-      /* coninuation */
-
-
-      return NULL;
-    }
-  }
-};
-
-#endif //TBB_VERSION
-/********************************************/
-
-
-
 int isIdentical(float *i, float *j, int D)
 // tells whether two points of D dimensions are identical
 {
-  int a = 0;
-  int equal = 1;
+    int a = 0;
+    int equal = 1;
 
-  while (equal && a < D) {
-    if (i[a] != j[a]) equal = 0;
-    else a++;
-  }
-  if (equal) return 1;
-  else return 0;
+    while (equal && a < D) {
+        if (i[a] != j[a]) equal = 0;
+        else a++;
+    }
+    if (equal) return 1;
+    else return 0;
 
 }
 
 /* comparator for floating point numbers */
 static int floatcomp(const void *i, const void *j)
 {
-  float a, b;
-  a = *(float *)(i);
-  b = *(float *)(j);
-  if (a > b) return (1);
-  if (a < b) return (-1);
-  return(0);
+    float a, b;
+    a = *(float *)(i);
+    b = *(float *)(j);
+    if (a > b) return (1);
+    if (a < b) return (-1);
+    return(0);
 }
 
 /* shuffle points into random order */
 void shuffle(Points *points)
 {
-  long i, j;
-  Point temp;
-  for (i=0;i<points->num-1;i++) {
-    j=(lrand48()%(points->num - i)) + i;
-    temp = points->p[i];
-    points->p[i] = points->p[j];
-    points->p[j] = temp;
-  }
+    long i, j;
+    Point temp;
+    for (i=0;i<points->num-1;i++) {
+        j=(lrand48()%(points->num - i)) + i;
+        temp = points->p[i];
+        points->p[i] = points->p[j];
+        points->p[j] = temp;
+    }
 }
 
 /* shuffle an array of integers */
 void intshuffle(int *intarray, int length)
 {
-  long i, j;
-  int temp;
-  for (i=0;i<length;i++) {
-    j=(lrand48()%(length - i))+i;
-    temp = intarray[i];
-    intarray[i]=intarray[j];
-    intarray[j]=temp;
-  }
+    long i, j;
+    int temp;
+    for (i=0;i<length;i++) {
+        j=(lrand48()%(length - i))+i;
+        temp = intarray[i];
+        intarray[i]=intarray[j];
+        intarray[j]=temp;
+    }
 }
 
+// Define access function to use as an alternative way to access array
+#define SK_P(x) (sk_block_a+x)
+
 /* compute Euclidean distance squared between two points */
+// SK: this does not seem to be called with Points from center as arguments, all of them are Points
 float dist(Point p1, Point p2, int dim)
 {
-  int i;
-  float result=0.0;
-  for (i=0;i<dim;i++)
-    result += (p1.coord[i] - p2.coord[i])*(p1.coord[i] - p2.coord[i]);
-  return(result);
-}
-
-#ifdef TBB_VERSION
-/* run speedy on the points, return total cost of solution */
-float pspeedy(Points *points, float z, long *kcenter)
-{
-  static double totalcost;
-  static bool open = false;
-  static double* costs; //cost for each thread. 
-  static int i;
-
-
-  /* create center at first point, send it to itself */
-  {
-    int grain_size = points->num / ((NUM_DIVISIONS));
-    CenterCreate c(points);
-    tbb::parallel_for(tbb::blocked_range<int>(0,points->num, grain_size),c);
-  }
-    
-  *kcenter = 1;
-
-
-  {
-    int grain_size = points->num / ((NUM_DIVISIONS));
-    double acc_cost = 0.0;
-    CenterOpen c(points);
-    for(i = 1; i < points->num; i++ )  {
-      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);
-      if( to_open )  {
-	(*kcenter)++;
-	c.i = i;
-	//fprintf(stderr,"** New center for i=%d\n",i);
-	tbb::parallel_reduce(tbb::blocked_range<int>(0,points->num,grain_size),c);
-      }
-    }
-
-    c.type = 1; /* Once last time for actual reduction */
-    tbb::parallel_reduce(tbb::blocked_range<int>(0,points->num,grain_size),c);
-
-
-    totalcost =z*(*kcenter);
-    totalcost += c.getTotalCost();
-  }
-  return(totalcost);
+    int i;
+    float result=0.0;
+    for (i=0;i<dim;i++)
+        result += (SK_P(p1.coord_idx)[i] - SK_P(p2.coord_idx)[i])*
+            (SK_P(p1.coord_idx)[i] - SK_P(p2.coord_idx)[i]);
+    return(result);
 }
 
-#else //!TBB_VERSION
-
 float pspeedy(Points *points, float z, long *kcenter, int pid, pthread_barrier_t* barrier)
 {
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  //my block
-  long bsize = points->num/nproc;
-  long k1 = bsize * pid;
-  long k2 = k1 + bsize;
-  if( pid == nproc-1 ) k2 = points->num;
+    //my block
+    long bsize = points->num/nproc;
+    long k1 = bsize * pid;
+    long k2 = k1 + bsize;
+    if( pid == nproc-1 ) k2 = points->num;
 
-  static double totalcost;
+    static double totalcost;
 
-  static bool open = false;
-  static double* costs; //cost for each thread. 
-  static int i;
+    static bool open = false;
+    static double* costs; //cost for each thread.
+    static int i;
 
 #ifdef ENABLE_THREADS
-  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
-  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
+    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
 #endif
 
-  /* create center at first point, send it to itself */
-  for( int k = k1; k < k2; k++ )    {
-    float distance = dist(points->p[k],points->p[0],points->dim);
-    points->p[k].cost = distance * points->p[k].weight;
-    points->p[k].assign=0;
-  }
+    /* create center at first point, send it to itself */
+    for( int k = k1; k < k2; k++ )    {
+        float distance = dist(points->p[k],points->p[0],points->dim);
+        points->p[k].cost = distance * points->p[k].weight;
+        points->p[k].assign=0;
+    }
 
-  if( pid==0 )   {
-    *kcenter = 1;
-    costs = (double*)malloc(sizeof(double)*nproc);
-  }
+    if( pid==0 )   {
+        *kcenter = 1;
+        costs = (double*)malloc(sizeof(double)*nproc);
+    }
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-    
-  if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.
-    while(1) {
+
+    if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.
+        while(1) {
 #ifdef ENABLE_THREADS
-      pthread_mutex_lock(&mutex);
-      while(!open) pthread_cond_wait(&cond,&mutex);
-      pthread_mutex_unlock(&mutex);
+            pthread_mutex_lock(&mutex);
+            while(!open) pthread_cond_wait(&cond,&mutex);
+            pthread_mutex_unlock(&mutex);
 #endif
-      if( i >= points->num ) break;
-      for( int k = k1; k < k2; k++ )
-	{
-	  float distance = dist(points->p[i],points->p[k],points->dim);
-	  if( distance*points->p[k].weight < points->p[k].cost )
-	    {
-	      points->p[k].cost = distance * points->p[k].weight;
-	      points->p[k].assign=i;
-	    }
-	}
+            if( i >= points->num ) break;
+            for( int k = k1; k < k2; k++ )
+                {
+                    float distance = dist(points->p[i],points->p[k],points->dim);
+                    if( distance*points->p[k].weight < points->p[k].cost )
+                        {
+                            points->p[k].cost = distance * points->p[k].weight;
+                            points->p[k].assign=i;
+                        }
+                }
 #ifdef ENABLE_THREADS
-      pthread_barrier_wait(barrier);
-      pthread_barrier_wait(barrier);
+            pthread_barrier_wait(barrier);
+            pthread_barrier_wait(barrier);
 #endif
-    } 
-  }
-  else  { // I am the master thread. I decide whether to open a center and notify others if so. 
-    for(i = 1; i < points->num; i++ )  {
-      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);
-      if( to_open )  {
-	(*kcenter)++;
+        }
+    }
+    else  { // I am the master thread. I decide whether to open a center and notify others if so.
+        for(i = 1; i < points->num; i++ )  {
+            bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);
+            if( to_open )  {
+                (*kcenter)++;
 #ifdef ENABLE_THREADS
-	pthread_mutex_lock(&mutex);
+                pthread_mutex_lock(&mutex);
 #endif
-	open = true;
+                open = true;
 #ifdef ENABLE_THREADS
-	pthread_mutex_unlock(&mutex);
-	pthread_cond_broadcast(&cond);
+                pthread_mutex_unlock(&mutex);
+                pthread_cond_broadcast(&cond);
 #endif
-	for( int k = k1; k < k2; k++ )  {
-	  float distance = dist(points->p[i],points->p[k],points->dim);
-	  if( distance*points->p[k].weight < points->p[k].cost )  {
-	    points->p[k].cost = distance * points->p[k].weight;
-	    points->p[k].assign=i;
-	  }
-	}
+                for( int k = k1; k < k2; k++ )  {
+                    float distance = dist(points->p[i],points->p[k],points->dim);
+                    if( distance*points->p[k].weight < points->p[k].cost )  {
+                        points->p[k].cost = distance * points->p[k].weight;
+                        points->p[k].assign=i;
+                    }
+                }
 #ifdef ENABLE_THREADS
-	pthread_barrier_wait(barrier);
+                pthread_barrier_wait(barrier);
 #endif
-	open = false;
+                open = false;
 #ifdef ENABLE_THREADS
-	pthread_barrier_wait(barrier);
+                pthread_barrier_wait(barrier);
 #endif
-      }
-    }
+            }
+        }
 #ifdef ENABLE_THREADS
-    pthread_mutex_lock(&mutex);
+        pthread_mutex_lock(&mutex);
 #endif
-    open = true;
+        open = true;
 #ifdef ENABLE_THREADS
-    pthread_mutex_unlock(&mutex);
-    pthread_cond_broadcast(&cond);
+        pthread_mutex_unlock(&mutex);
+        pthread_cond_broadcast(&cond);
 #endif
-  }
+    }
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  open = false;
-  double mytotal = 0;
-  for( int k = k1; k < k2; k++ )  {
-    mytotal += points->p[k].cost;
-  }
-  costs[pid] = mytotal;
+    open = false;
+    double mytotal = 0;
+    for( int k = k1; k < k2; k++ )  {
+        mytotal += points->p[k].cost;
+    }
+    costs[pid] = mytotal;
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  // aggregate costs from each thread
-  if( pid == 0 )
-    {
-      totalcost=z*(*kcenter);
-      for( int i = 0; i < nproc; i++ )
-	{
-	  totalcost += costs[i];
-	} 
-      free(costs);
-    }
+    // aggregate costs from each thread
+    if( pid == 0 )
+        {
+            totalcost=z*(*kcenter);
+            for( int i = 0; i < nproc; i++ )
+                {
+                    totalcost += costs[i];
+                }
+            free(costs);
+        }
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
 
-  return(totalcost);
+    return(totalcost);
 }
 
-#endif // TBB_VERSION
-
-
 /* For a given point x, find the cost of the following operation:
  * -- open a facility at x if there isn't already one there,
  * -- for points y such that the assignment distance of y exceeds dist(y, x),
  *    make y a member of x,
- * -- for facilities y such that reassigning y and all its members to x 
+ * -- for facilities y such that reassigning y and all its members to x
  *    would save cost, realize this closing and reassignment.
- * 
+ *
  * If the cost of this operation is negative (i.e., if this entire operation
  * saves cost), perform this operation and return the amount of cost saved;
  * otherwise, do nothing.
  */
 
 /* numcenters will be updated to reflect the new number of centers */
-/* z is the facility cost, x is the number of this point in the array 
+/* z is the facility cost, x is the number of this point in the array
    points */
-
-
-#ifdef TBB_VERSION
-double pgain(long x, Points *points, double z, long int *numcenters)
-{
-  int i;
-  int number_of_centers_to_close = 0;
-
-  static double *work_mem;
-  static double gl_cost_of_opening_x;
-  static int gl_number_of_centers_to_close;
-
-  //each thread takes a block of working_mem.
-  int stride = *numcenters+2;
-
-  //make stride a multiple of CACHE_LINE
-  int cl = CACHE_LINE/sizeof(double);
-  if( stride % cl != 0 ) { 
-    stride = cl * ( stride / cl + 1);
-  }
-  int K = stride -2 ; // K==*numcenters
-  
-  //my own cost of opening x
-  double cost_of_opening_x = 0;
-
-  work_mem = (double*) calloc(stride*((NUM_DIVISIONS)+1),sizeof(double));
-  
-  gl_cost_of_opening_x = 0;
-  gl_number_of_centers_to_close = 0;
-
-
-  /*For each center, we have a *lower* field that indicates 
-    how much we will save by closing the center. 
-    Each thread has its own copy of the *lower* fields as an array.
-    We first build a table to index the positions of the *lower* fields. 
-  */
-
-  /*****  loopA() *****/
-  {
-    CenterTableCountTask &t = *new ( tbb::task::allocate_root() ) CenterTableCountTask(stride, points, work_mem);
-    tbb::task::spawn_root_and_wait(t);
-  }
-
-  
-  {
-    FixCenterTask &t = *new ( tbb::task::allocate_root() ) FixCenterTask(stride, points, work_mem);
-    tbb::task::spawn_root_and_wait(t);
-  }    
-
-  /***************/
-
-  //now we finish building the table. clear the working memory.
-  memset(switch_membership, 0, points->num*sizeof(bool));
-  memset(work_mem, 0, (NUM_DIVISIONS+1)*stride*sizeof(double));
-
-  /* loopB */
-  {
-    LowerCostTask &t = *new ( tbb::task::allocate_root() )  LowerCostTask(stride, points, x, work_mem, K);
-    tbb::task::spawn_root_and_wait(t);
-  }    
-
-  /* LoopC */
-  {
-    CenterCloseTask &t = *new ( tbb::task::allocate_root() )  CenterCloseTask(stride, points, work_mem, K, z);
-    tbb::task::spawn_root_and_wait(t);
-  }    
-
-
-  gl_cost_of_opening_x = z;
-  //aggregate
-  for( int p = 0; p < (NUM_DIVISIONS); p++ ) {
-    gl_number_of_centers_to_close += (int)work_mem[p*stride + K];
-    gl_cost_of_opening_x += work_mem[p*stride+K+1];
-  }
-
-  /*fprintf(stderr,"\tgl_number_of_centers_to_close = %d\n",gl_number_of_centers_to_close);
-    fprintf(stderr,"\tgl_cost_of_opening_x = %lf\n",gl_cost_of_opening_x); */
-
-
-  // Now, check whether opening x would save cost; if so, do it, and
-  // otherwise do nothing
-
-  if ( gl_cost_of_opening_x < 0 ) {
-
-    /* loopD */
-    SaveMoneyTask &t = *new ( tbb::task::allocate_root() )  SaveMoneyTask(stride, points, x, work_mem);
-    tbb::task::spawn_root_and_wait(t);
-
-
-    *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;    
-  }
-  else {
-    gl_cost_of_opening_x = 0;  // the value we'll return
-  }
-
-  free(work_mem);
-
-  return -gl_cost_of_opening_x;
-}
-
-#else //!TBB_VERSION
-
-
 double pgain(long x, Points *points, double z, long int *numcenters, int pid, pthread_barrier_t* barrier)
 {
-  //  printf("pgain pthread %d begin\n",pid);
+    //  printf("pgain pthread %d begin\n",pid);
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
 
-  //my block
-  long bsize = points->num/nproc;
-  long k1 = bsize * pid;
-  long k2 = k1 + bsize;
-  if( pid == nproc-1 ) k2 = points->num;
-
-  int i;
-  int number_of_centers_to_close = 0;
-
-  static double *work_mem;
-  static double gl_cost_of_opening_x;
-  static int gl_number_of_centers_to_close;
+    //my block
+    long bsize = points->num/nproc;
+    long k1 = bsize * pid;
+    long k2 = k1 + bsize;
+    if( pid == nproc-1 ) k2 = points->num;
 
-  //each thread takes a block of working_mem.
-  int stride = *numcenters+2;
-  //make stride a multiple of CACHE_LINE
-  int cl = CACHE_LINE/sizeof(double);
-  if( stride % cl != 0 ) { 
-    stride = cl * ( stride / cl + 1);
-  }
-  int K = stride -2 ; // K==*numcenters
-  
-  //my own cost of opening x
-  double cost_of_opening_x = 0;
+    int i;
+    int number_of_centers_to_close = 0;
 
-  if( pid==0 )    { 
-    work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));
-    gl_cost_of_opening_x = 0;
-    gl_number_of_centers_to_close = 0;
-  }
+    static double *work_mem;
+    static double gl_cost_of_opening_x;
+    static int gl_number_of_centers_to_close;
+
+    //each thread takes a block of working_mem.
+    int stride = *numcenters+2;
+    //make stride a multiple of CACHE_LINE
+    int cl = CACHE_LINE/sizeof(double);
+    if( stride % cl != 0 ) {
+        stride = cl * ( stride / cl + 1);
+    }
+    int K = stride -2 ; // K==*numcenters
+
+    //my own cost of opening x
+    double cost_of_opening_x = 0;
+
+    if( pid==0 )    {
+        work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));
+        gl_cost_of_opening_x = 0;
+        gl_number_of_centers_to_close = 0;
+    }
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  /*For each center, we have a *lower* field that indicates 
-    how much we will save by closing the center. 
-    Each thread has its own copy of the *lower* fields as an array.
-    We first build a table to index the positions of the *lower* fields. 
-  */
+    /*For each center, we have a *lower* field that indicates
+      how much we will save by closing the center.
+      Each thread has its own copy of the *lower* fields as an array.
+      We first build a table to index the positions of the *lower* fields.
+    */
 
-  int count = 0;
-  for( int i = k1; i < k2; i++ ) {
-    if( is_center[i] ) {
-      center_table[i] = count++;
+    int count = 0;
+    for( int i = k1; i < k2; i++ ) {
+        if( is_center[i] ) {
+            center_table[i] = count++;
+        }
     }
-  }
-  work_mem[pid*stride] = count;
+    work_mem[pid*stride] = count;
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
 
-  if( pid == 0 ) {
-    int accum = 0;
-    for( int p = 0; p < nproc; p++ ) {
-      int tmp = (int)work_mem[p*stride];
-      work_mem[p*stride] = accum;
-      accum += tmp;
+    if( pid == 0 ) {
+        int accum = 0;
+        for( int p = 0; p < nproc; p++ ) {
+            int tmp = (int)work_mem[p*stride];
+            work_mem[p*stride] = accum;
+            accum += tmp;
+        }
     }
-  }
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
 
-  for( int i = k1; i < k2; i++ ) {
-    if( is_center[i] ) {
-      center_table[i] += (int)work_mem[pid*stride];
+    for( int i = k1; i < k2; i++ ) {
+        if( is_center[i] ) {
+            center_table[i] += (int)work_mem[pid*stride];
+        }
     }
-  }
 
-  //now we finish building the table. clear the working memory.
-  memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));
-  memset(work_mem+pid*stride, 0, stride*sizeof(double));
-  if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));
+    //now we finish building the table. clear the working memory.
+    memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));
+    memset(work_mem+pid*stride, 0, stride*sizeof(double));
+    if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  
-  //my *lower* fields
-  double* lower = &work_mem[pid*stride];
-  //global *lower* fields
-  double* gl_lower = &work_mem[nproc*stride];
-
-  for ( i = k1; i < k2; i++ ) {
-    float x_cost = dist(points->p[i], points->p[x], points->dim) 
-      * points->p[i].weight;
-    float current_cost = points->p[i].cost;
-
-    if ( x_cost < current_cost ) {
 
-      // point i would save cost just by switching to x
-      // (note that i cannot be a median, 
-      // or else dist(p[i], p[x]) would be 0)
-      
-      switch_membership[i] = 1;
-      cost_of_opening_x += x_cost - current_cost;
-
-    } else {
-
-      // cost of assigning i to x is at least current assignment cost of i
+    //my *lower* fields
+    double* lower = &work_mem[pid*stride];
+    //global *lower* fields
+    double* gl_lower = &work_mem[nproc*stride];
 
-      // consider the savings that i's **current** median would realize
-      // if we reassigned that median and all its members to x;
-      // note we've already accounted for the fact that the median
-      // would save z by closing; now we have to subtract from the savings
-      // the extra cost of reassigning that median and its members 
-      int assign = points->p[i].assign;
-      lower[center_table[assign]] += current_cost - x_cost;
+    for ( i = k1; i < k2; i++ ) {
+        float x_cost = dist(points->p[i], points->p[x], points->dim)
+            * points->p[i].weight;
+        float current_cost = points->p[i].cost;
+
+        if ( x_cost < current_cost ) {
+
+            // point i would save cost just by switching to x
+            // (note that i cannot be a median,
+            // or else dist(p[i], p[x]) would be 0)
+
+            switch_membership[i] = 1;
+            cost_of_opening_x += x_cost - current_cost;
+
+        } else {
+
+            // cost of assigning i to x is at least current assignment cost of i
+
+            // consider the savings that i's **current** median would realize
+            // if we reassigned that median and all its members to x;
+            // note we've already accounted for the fact that the median
+            // would save z by closing; now we have to subtract from the savings
+            // the extra cost of reassigning that median and its members
+            int assign = points->p[i].assign;
+            lower[center_table[assign]] += current_cost - x_cost;
+        }
     }
-  }
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
 
-  // at this time, we can calculate the cost of opening a center
-  // at x; if it is negative, we'll go through with opening it
-
-  for ( int i = k1; i < k2; i++ ) {
-    if( is_center[i] ) {
-      double low = z;
-      //aggregate from all threads
-      for( int p = 0; p < nproc; p++ ) {
-	low += work_mem[center_table[i]+p*stride];
-      }
-      gl_lower[center_table[i]] = low;
-      if ( low > 0 ) {
-	// i is a median, and
-	// if we were to open x (which we still may not) we'd close i
+    // at this time, we can calculate the cost of opening a center
+    // at x; if it is negative, we'll go through with opening it
 
-	// note, we'll ignore the following quantity unless we do open x
-	++number_of_centers_to_close;  
-	cost_of_opening_x -= low;
-      }
-    }
-  }
-  //use the rest of working memory to store the following
-  work_mem[pid*stride + K] = number_of_centers_to_close;
-  work_mem[pid*stride + K+1] = cost_of_opening_x;
+    for ( int i = k1; i < k2; i++ ) {
+        if( is_center[i] ) {
+            double low = z;
+            //aggregate from all threads
+            for( int p = 0; p < nproc; p++ ) {
+                low += work_mem[center_table[i]+p*stride];
+            }
+            gl_lower[center_table[i]] = low;
+            if ( low > 0 ) {
+                // i is a median, and
+                // if we were to open x (which we still may not) we'd close i
+
+                // note, we'll ignore the following quantity unless we do open x
+                ++number_of_centers_to_close;
+                cost_of_opening_x -= low;
+            }
+        }
+    }
+    //use the rest of working memory to store the following
+    work_mem[pid*stride + K] = number_of_centers_to_close;
+    work_mem[pid*stride + K+1] = cost_of_opening_x;
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  //  printf("thread %d cost complete\n",pid); 
+    //  printf("thread %d cost complete\n",pid);
 
-  if( pid==0 ) {
-    gl_cost_of_opening_x = z;
-    //aggregate
-    for( int p = 0; p < nproc; p++ ) {
-      gl_number_of_centers_to_close += (int)work_mem[p*stride + K];
-      gl_cost_of_opening_x += work_mem[p*stride+K+1];
+    if( pid==0 ) {
+        gl_cost_of_opening_x = z;
+        //aggregate
+        for( int p = 0; p < nproc; p++ ) {
+            gl_number_of_centers_to_close += (int)work_mem[p*stride + K];
+            gl_cost_of_opening_x += work_mem[p*stride+K+1];
+        }
     }
-  }
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
+    pthread_barrier_wait(barrier);
 #endif
-  // Now, check whether opening x would save cost; if so, do it, and
-  // otherwise do nothing
+    // Now, check whether opening x would save cost; if so, do it, and
+    // otherwise do nothing
 
-  if ( gl_cost_of_opening_x < 0 ) {
-    //  we'd save money by opening x; we'll do it
-    for ( int i = k1; i < k2; i++ ) {
-      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;
-      if ( switch_membership[i] || close_center ) {
-	// Either i's median (which may be i itself) is closing,
-	// or i is closer to x than to its current median
-	points->p[i].cost = points->p[i].weight *
-	  dist(points->p[i], points->p[x], points->dim);
-	points->p[i].assign = x;
-      }
-    }
-    for( int i = k1; i < k2; i++ ) {
-      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {
-	is_center[i] = false;
-      }
+    if ( gl_cost_of_opening_x < 0 ) {
+        //  we'd save money by opening x; we'll do it
+        for ( int i = k1; i < k2; i++ ) {
+            bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;
+            if ( switch_membership[i] || close_center ) {
+                // Either i's median (which may be i itself) is closing,
+                // or i is closer to x than to its current median
+                points->p[i].cost = points->p[i].weight *
+                    dist(points->p[i], points->p[x], points->dim);
+                points->p[i].assign = x;
+            }
+        }
+        for( int i = k1; i < k2; i++ ) {
+            if( is_center[i] && gl_lower[center_table[i]] > 0 ) {
+                is_center[i] = false;
+            }
+        }
+        if( x >= k1 && x < k2 ) {
+            is_center[x] = true;
+        }
+
+        if( pid==0 ) {
+            *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;
+        }
     }
-    if( x >= k1 && x < k2 ) {
-      is_center[x] = true;
+    else {
+        if( pid==0 )
+            gl_cost_of_opening_x = 0;  // the value we'll return
     }
-
-    if( pid==0 ) {
-      *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;
+#ifdef ENABLE_THREADS
+    pthread_barrier_wait(barrier);
+#endif
+    if( pid == 0 ) {
+        free(work_mem);
+        //    free(is_center);
+        //    free(switch_membership);
+        //    free(proc_cost_of_opening_x);
+        //    free(proc_number_of_centers_to_close);
     }
-  }
-  else {
-    if( pid==0 )
-      gl_cost_of_opening_x = 0;  // the value we'll return
-  }
-#ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
-#endif
-  if( pid == 0 ) {
-    free(work_mem);
-    //    free(is_center);
-    //    free(switch_membership);
-    //    free(proc_cost_of_opening_x);
-    //    free(proc_number_of_centers_to_close);
-  }
 
-  return -gl_cost_of_opening_x;
+    return -gl_cost_of_opening_x;
 }
 
-#endif // TBB_VERSION
-
-
 
 /* facility location on the points using local search */
 /* z is the facility cost, returns the total cost and # of centers */
@@ -1170,571 +548,418 @@ double pgain(long x, Points *points, dou
 /* cost should represent this solution's cost */
 /* halt if there is < e improvement after iter calls to gain */
 /* feasible is an array of numfeasible points which may be centers */
-
-#ifdef TBB_VERSION
 float pFL(Points *points, int *feasible, int numfeasible,
-	  double z, long *k, double cost, long iter, double e)
-{
-
-  long i;
-  long x;
-  double change;
-  long numberOfPoints;
-
-  change = cost;
-  /* continue until we run iter iterations without improvement */
-  /* stop instead if improvement is less than e */
-  while (change/cost > 1.0*e) {
-    change = 0.0;
-    numberOfPoints = points->num;
-    /* randomize order in which centers are considered */    
-    intshuffle(feasible, numfeasible);
-
-    for (i=0;i<iter;i++) {
-      x = i%numfeasible;
-      //fprintf(stderr,"Iteration %d z=%lf, change=%lf\n",i,z,change);
-      change += pgain(feasible[x], points, z , k);
-      //fprintf(stderr,"*** change: %lf, z=%lf\n",change,z);
-    }
-    cost -= change;
-  }
-
-  return(cost);
-}
-
-
-#else //!TBB_VERSION
- float pFL(Points *points, int *feasible, int numfeasible,
-	  float z, long *k, double cost, long iter, float e, 
-	  int pid, pthread_barrier_t* barrier)
+          float z, long *k, double cost, long iter, float e,
+          int pid, pthread_barrier_t* barrier)
 {
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
-#endif
-  long i;
-  long x;
-  double change;
-  long numberOfPoints;
-
-  change = cost;
-  /* continue until we run iter iterations without improvement */
-  /* stop instead if improvement is less than e */
-  while (change/cost > 1.0*e) {
-    change = 0.0;
-    numberOfPoints = points->num;
-    /* randomize order in which centers are considered */
-
-    if( pid == 0 ) {
-      intshuffle(feasible, numfeasible);
-    }
-#ifdef ENABLE_THREADS
     pthread_barrier_wait(barrier);
 #endif
-    for (i=0;i<iter;i++) {
-      x = i%numfeasible;
-      change += pgain(feasible[x], points, z, k, pid, barrier);
-    }
-    cost -= change;
+    long i;
+    long x;
+    double change;
+    long numberOfPoints;
+
+    change = cost;
+    /* continue until we run iter iterations without improvement */
+    /* stop instead if improvement is less than e */
+    while (change/cost > 1.0*e) {
+        change = 0.0;
+        numberOfPoints = points->num;
+        /* randomize order in which centers are considered */
+
+        if( pid == 0 ) {
+            intshuffle(feasible, numfeasible);
+        }
+#ifdef ENABLE_THREADS
+        pthread_barrier_wait(barrier);
+#endif
+        for (i=0;i<iter;i++) {
+            x = i%numfeasible;
+            change += pgain(feasible[x], points, z, k, pid, barrier);
+        }
+        cost -= change;
 #ifdef ENABLE_THREADS
-    pthread_barrier_wait(barrier);
+        pthread_barrier_wait(barrier);
 #endif
-  }
-  return(cost);
+    }
+    return(cost);
 }
 
-#endif // TBB_VERSION
-
-
-
-#ifdef TBB_VERSION
-int selectfeasible_fast(Points *points, int **feasible, int kmin)
-#else
 int selectfeasible_fast(Points *points, int **feasible, int kmin, int pid, pthread_barrier_t* barrier)
-#endif
 {
-  int numfeasible = points->num;
-  if (numfeasible > (ITER*kmin*log((double)kmin)))
-    numfeasible = (int)(ITER*kmin*log((double)kmin));
-  *feasible = (int *)malloc(numfeasible*sizeof(int));
-  
-  float* accumweight;
-  float totalweight;
-
-  /* 
-     Calcuate my block. 
-     For now this routine does not seem to be the bottleneck, so it is not parallelized. 
-     When necessary, this can be parallelized by setting k1 and k2 to 
-     proper values and calling this routine from all threads ( it is called only
-     by thread 0 for now ). 
-     Note that when parallelized, the randomization might not be the same and it might
-     not be difficult to measure the parallel speed-up for the whole program. 
-   */
-  //  long bsize = numfeasible;
-  long k1 = 0;
-  long k2 = numfeasible;
-
-  float w;
-  int l,r,k;
-
-  /* not many points, all will be feasible */
-  if (numfeasible == points->num) {
-    for (int i=k1;i<k2;i++)
-      (*feasible)[i] = i;
-    return numfeasible;
-  }
-#ifdef TBB_VERSION
-  accumweight= (float*)memoryFloat.allocate(sizeof(float)*points->num);
-#else
-  accumweight= (float*)malloc(sizeof(float)*points->num);
-#endif
+    int numfeasible = points->num;
+    if (numfeasible > (ITER*kmin*log((double)kmin)))
+        numfeasible = (int)(ITER*kmin*log((double)kmin));
+    *feasible = (int *)malloc(numfeasible*sizeof(int));
+
+    float* accumweight;
+    float totalweight;
+
+    /*
+      Calcuate my block.
+      For now this routine does not seem to be the bottleneck, so it is not parallelized.
+      When necessary, this can be parallelized by setting k1 and k2 to
+      proper values and calling this routine from all threads ( it is called only
+      by thread 0 for now ).
+      Note that when parallelized, the randomization might not be the same and it might
+      not be difficult to measure the parallel speed-up for the whole program.
+    */
+    //  long bsize = numfeasible;
+    long k1 = 0;
+    long k2 = numfeasible;
 
-  accumweight[0] = points->p[0].weight;
-  totalweight=0;
-  for( int i = 1; i < points->num; i++ ) {
-    accumweight[i] = accumweight[i-1] + points->p[i].weight;
-  }
-  totalweight=accumweight[points->num-1];
-
-  for(int i=k1; i<k2; i++ ) {
-    w = (lrand48()/(float)INT_MAX)*totalweight;
-    //binary search
-    l=0;
-    r=points->num-1;
-    if( accumweight[0] > w )  { 
-      (*feasible)[i]=0; 
-      continue;
-    }
-    while( l+1 < r ) {
-      k = (l+r)/2;
-      if( accumweight[k] > w ) {
-	r = k;
-      } 
-      else {
-	l=k;
-      }
+    float w;
+    int l,r,k;
+
+    /* not many points, all will be feasible */
+    if (numfeasible == points->num) {
+        for (int i=k1;i<k2;i++)
+            (*feasible)[i] = i;
+        return numfeasible;
+    }
+    accumweight= (float*)malloc(sizeof(float)*points->num);
+
+    accumweight[0] = points->p[0].weight;
+    totalweight=0;
+    for( int i = 1; i < points->num; i++ ) {
+        accumweight[i] = accumweight[i-1] + points->p[i].weight;
+    }
+    totalweight=accumweight[points->num-1];
+
+    for(int i=k1; i<k2; i++ ) {
+        w = (lrand48()/(float)INT_MAX)*totalweight;
+        //binary search
+        l=0;
+        r=points->num-1;
+        if( accumweight[0] > w )  {
+            (*feasible)[i]=0;
+            continue;
+        }
+        while( l+1 < r ) {
+            k = (l+r)/2;
+            if( accumweight[k] > w ) {
+                r = k;
+            }
+            else {
+                l=k;
+            }
+        }
+        (*feasible)[i]=r;
     }
-    (*feasible)[i]=r;
-  }
 
-#ifdef TBB_VERSION
-  memoryFloat.deallocate(accumweight, sizeof(float));
-#else
-  free(accumweight); 
-#endif
+    free(accumweight);
 
-  return numfeasible;
+    return numfeasible;
 }
 
-
-
-#ifdef TBB_VERSION
 /* compute approximate kmedian on the points */
 float pkmedian(Points *points, long kmin, long kmax, long* kfinal,
-	       int pid, pthread_barrier_t* barrier )
+               int pid, pthread_barrier_t* barrier )
 {
-  int i;
-  double cost;
-  double lastcost;
-  double hiz, loz, z;
-
-  static long k;
-  static int *feasible;
-  static int numfeasible;
-  static double* hizs;
-
-
-  //  hizs = (double*)calloc(nproc,sizeof(double));
-  hiz = loz = 0.0;
-  long numberOfPoints = points->num;
-  long ptDimension = points->dim;
-
-  //my block
-  long bsize = points->num/nproc;
-  long k1 = bsize * pid;
-  long k2 = k1 + bsize;
-  if( pid == nproc-1 ) k2 = points->num;
-
-  
-  //fprintf(stderr,"Starting Kmedian procedure\n");
-  //fprintf(stderr,"%i points in %i dimensions\n", numberOfPoints, ptDimension);
-
-  int grain_size = points->num / ((NUM_DIVISIONS));
-  if(grain_size==0)
-    {
-      
-      for (long kk=0;kk < points->num; kk++ ) 
-	{
-	  hiz += dist(points->p[kk], points->p[0],
-		      ptDimension)*points->p[kk].weight;
-	}
-      
-    }
-  else {
-    HizReduction h(points);
-    tbb::parallel_reduce(tbb::blocked_range<int>(0,points->num, grain_size), h);
-    hiz = h.getHiz();
-  }
-
-  loz=0.0; z = (hiz+loz)/2.0;
-
-  /* NEW: Check whether more centers than points! */
-  if (points->num <= kmax) {
-    /* just return all points as facilities */
-      for (long kk=0;kk<points->num;kk++) 
-	{
-	  points->p[kk].assign = kk;
-	  points->p[kk].cost = 0;
-	}
-    
-    cost = 0;
-    *kfinal = k;
-
-    return cost;
-  }
-
-    shuffle(points);
-    cost = pspeedy(points, z, &k);
-
-    i=0;
+    static int skpkmit = 0;
+    int i;
+    double cost;
+    double lastcost;
+    double hiz, loz, z;
+
+    static long k;
+    static int *feasible;
+    static int numfeasible;
+    static double* hizs;
+
+    if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));
+    hiz = loz = 0.0;
+    long numberOfPoints = points->num;
+    long ptDimension = points->dim;
 
-  /* give speedy SP chances to get at least kmin/2 facilities */
-  while ((k < kmin)&&(i<SP)) {
-    cost = pspeedy(points, z, &k);
-    i++;
-  }
-
-  /* if still not enough facilities, assume z is too high */
-  while (k < kmin) {
-    if (i >= SP) 
-      {hiz=z; z=(hiz+loz)/2.0; i=0;}
-    
-    shuffle(points);
-    cost =  pspeedy(points, z, &k);
-    i++;
-  }
-
-  /* now we begin the binary search for real */
-  /* must designate some points as feasible centers */
-  /* this creates more consistancy between FL runs */
-  /* helps to guarantee correct # of centers at the end */
-
-    numfeasible = selectfeasible_fast(points,&feasible,kmin);
-    for( int i = 0; i< points->num; i++ ) {
-      //fprintf(stderr,"\t-->is_center[%d]=true!\n",points->p[i].assign);
-      is_center[points->p[i].assign]= true;
-    }
-
-
-  while(1) {
-    /* first get a rough estimate on the FL solution */
-    lastcost = cost;
-    cost = pFL(points, feasible, numfeasible,
-	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1);
-
-    /* if number of centers seems good, try a more accurate FL */
-    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||
-	((k <= kmax+2)&&(k >= kmin-2))) {
-      
-      /* may need to run a little longer here before halting without
-	 improvement */
-      cost = pFL(points, feasible, numfeasible,
-		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001);
-    }
-
-    if (k > kmax) {
-      /* facilities too cheap */
-      /* increase facility cost and up the cost accordingly */
-      loz = z; z = (hiz+loz)/2.0;
-      cost += (z-loz)*k;
-    }
-    if (k < kmin) {
-      /* facilities too expensive */
-      /* decrease facility cost and reduce the cost accordingly */
-      hiz = z; z = (hiz+loz)/2.0;
-      cost += (z-hiz)*k;
-    }
-
-    /* if k is good, return the result */
-    /* if we're stuck, just give up and return what we have */
-    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )
-      { 
-	break;
-      }
-
-  }
-
-  //  fprintf(stderr,"Cleaning up...\n");
-  //clean up...
-  free(feasible); 
-  *kfinal = k;
+    //my block
+    long bsize = points->num/nproc;
+    // --------------------------------------------------
+    // select range of array this thread should work on
+    long k1 = bsize * pid;
+    long k2 = k1 + bsize;
+    // --------------------------------------------------
+    if( pid == nproc-1 ) k2 = points->num;
 
-  return cost;
-}
+#ifdef ENABLE_THREADS
+    pthread_barrier_wait(barrier);
+#endif
 
+    double myhiz = 0;
+    for (long kk=k1;kk < k2; kk++ ) {
+        // SK: Indexed access
+        myhiz += dist(points->p[kk], points->p[0],
+                      ptDimension)*points->p[kk].weight;
+    }
+    hizs[pid] = myhiz;
 
-#else //!TBB_VERSION
+#ifdef ENABLE_THREADS
+    pthread_barrier_wait(barrier);
+#endif
 
-/* compute approximate kmedian on the points */
-float pkmedian(Points *points, long kmin, long kmax, long* kfinal,
-	       int pid, pthread_barrier_t* barrier )
-{
-  int i;
-  double cost;
-  double lastcost;
-  double hiz, loz, z;
-
-  static long k;
-  static int *feasible;
-  static int numfeasible;
-  static double* hizs;
-
-  if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));
-  hiz = loz = 0.0;
-  long numberOfPoints = points->num;
-  long ptDimension = points->dim;
-
-  //my block
-  long bsize = points->num/nproc;
-  long k1 = bsize * pid;
-  long k2 = k1 + bsize;
-  if( pid == nproc-1 ) k2 = points->num;
-
-#ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
-#endif
-
-  double myhiz = 0;
-  for (long kk=k1;kk < k2; kk++ ) {
-    myhiz += dist(points->p[kk], points->p[0],
-		      ptDimension)*points->p[kk].weight;
-  }
-  hizs[pid] = myhiz;
-
-#ifdef ENABLE_THREADS  
-  pthread_barrier_wait(barrier);
-#endif
-
-  for( int i = 0; i < nproc; i++ )   {
-    hiz += hizs[i];
-  }
-
-  loz=0.0; z = (hiz+loz)/2.0;
-  /* NEW: Check whether more centers than points! */
-  if (points->num <= kmax) {
-    /* just return all points as facilities */
-    for (long kk=k1;kk<k2;kk++) {
-      points->p[kk].assign = kk;
-      points->p[kk].cost = 0;
-    }
-    cost = 0;
-    if( pid== 0 ) {
-      free(hizs); 
-      *kfinal = k;
+    for( int i = 0; i < nproc; i++ )   {
+        hiz += hizs[i];
     }
-    return cost;
-  }
-
-  if( pid == 0 ) shuffle(points);
-  cost = pspeedy(points, z, &k, pid, barrier);
 
-  i=0;
-  /* give speedy SP chances to get at least kmin/2 facilities */
-  while ((k < kmin)&&(i<SP)) {
-    cost = pspeedy(points, z, &k, pid, barrier);
-    i++;
-  }
+    loz=0.0; z = (hiz+loz)/2.0;
+    /* NEW: Check whether more centers than points! */
+    if (points->num <= kmax) {
+        /* just return all points as facilities */
+        for (long kk=k1;kk<k2;kk++) {
+            points->p[kk].assign = kk;
+            points->p[kk].cost = 0;
+        }
+        cost = 0;
+        if( pid== 0 ) {
+
+#ifdef SK_CRC_RUNTIME
+            // hizs
+            crc_t crc_h;
+            crc_h = crc_init();
+            crc_h = crc_update(crc_h, (unsigned char*) hizs, nproc*sizeof(double));
+            crc_h = crc_finalize(crc_h);
+            printf("Iteration %d: hizs=0x%lx\n", skpkmit++, crc_h);
+#endif /* SK_CRC_RUNTIME */
+
+            free(hizs);
+            *kfinal = k;
+        }
+        return cost;
+    }
 
-  /* if still not enough facilities, assume z is too high */
-  while (k < kmin) {
-    if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}
     if( pid == 0 ) shuffle(points);
     cost = pspeedy(points, z, &k, pid, barrier);
-    i++;
-  }
 
-  /* now we begin the binary search for real */
-  /* must designate some points as feasible centers */
-  /* this creates more consistancy between FL runs */
-  /* helps to guarantee correct # of centers at the end */
-  
-  if( pid == 0 )
-    {
-      numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);
-      for( int i = 0; i< points->num; i++ ) {
-	is_center[points->p[i].assign]= true;
-      }
-    }
+    i=0;
+    /* give speedy SP chances to get at least kmin/2 facilities */
+    while ((k < kmin)&&(i<SP)) {
+        cost = pspeedy(points, z, &k, pid, barrier);
+        i++;
+    }
+
+    /* if still not enough facilities, assume z is too high */
+    while (k < kmin) {
+        if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}
+        if( pid == 0 ) shuffle(points);
+        cost = pspeedy(points, z, &k, pid, barrier);
+        i++;
+    }
+
+    /* now we begin the binary search for real */
+    /* must designate some points as feasible centers */
+    /* this creates more consistancy between FL runs */
+    /* helps to guarantee correct # of centers at the end */
+
+    if( pid == 0 )
+        {
+            numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);
+            for( int i = 0; i< points->num; i++ ) {
+                is_center[points->p[i].assign]= true;
+            }
+        }
 
 #ifdef ENABLE_THREADS
-  pthread_barrier_wait(barrier);
-#endif
-
-  while(1) {
-    /* first get a rough estimate on the FL solution */
-    lastcost = cost;
-    cost = pFL(points, feasible, numfeasible,
-	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);
-
-    /* if number of centers seems good, try a more accurate FL */
-    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||
-	((k <= kmax+2)&&(k >= kmin-2))) {
-
-      /* may need to run a little longer here before halting without
-	 improvement */
-      cost = pFL(points, feasible, numfeasible,
-		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);
-    }
-
-    if (k > kmax) {
-      /* facilities too cheap */
-      /* increase facility cost and up the cost accordingly */
-      loz = z; z = (hiz+loz)/2.0;
-      cost += (z-loz)*k;
-    }
-    if (k < kmin) {
-      /* facilities too expensive */
-      /* decrease facility cost and reduce the cost accordingly */
-      hiz = z; z = (hiz+loz)/2.0;
-      cost += (z-hiz)*k;
-    }
-
-    /* if k is good, return the result */
-    /* if we're stuck, just give up and return what we have */
-    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )
-      { 
-	break;
-      }
-#ifdef ENABLE_THREADS
     pthread_barrier_wait(barrier);
 #endif
-  }
-
-  //clean up...
-  if( pid==0 ) {
-    free(feasible); 
-    free(hizs);
-    *kfinal = k;
-  }
 
-  return cost;
-}
+    while(1) {
+        /* first get a rough estimate on the FL solution */
+        lastcost = cost;
+        cost = pFL(points, feasible, numfeasible,
+                   z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);
+
+        /* if number of centers seems good, try a more accurate FL */
+        if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||
+            ((k <= kmax+2)&&(k >= kmin-2))) {
+
+            /* may need to run a little longer here before halting without
+               improvement */
+            cost = pFL(points, feasible, numfeasible,
+                       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);
+        }
+
+        if (k > kmax) {
+            /* facilities too cheap */
+            /* increase facility cost and up the cost accordingly */
+            loz = z; z = (hiz+loz)/2.0;
+            cost += (z-loz)*k;
+        }
+        if (k < kmin) {
+            /* facilities too expensive */
+            /* decrease facility cost and reduce the cost accordingly */
+            hiz = z; z = (hiz+loz)/2.0;
+            cost += (z-hiz)*k;
+        }
+
+        /* if k is good, return the result */
+        /* if we're stuck, just give up and return what we have */
+        if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )
+            {
+                break;
+            }
+#ifdef ENABLE_THREADS
+        pthread_barrier_wait(barrier);
+#endif
+    }
 
-#endif // TBB_VERSION
+    //clean up...
+    if( pid==0 ) {
 
+#ifdef SK_CRC_RUNTIME
+        // hizs
+        crc_t crc_h;
+        crc_h = crc_init();
+        crc_h = crc_update(crc_h, (unsigned char*) hizs, nproc*sizeof(double));
+        crc_h = crc_finalize(crc_h);
+        printf("Iteration %d: hizs=0x%lx\n", skpkmit++, crc_h);
+#endif /* SK_CRC_RUNTIME */
+
+        free(feasible);
+        free(hizs);
+        *kfinal = k;
+    }
 
+    return cost;
+}
 
 
 /* compute the means for the k clusters */
+// This is execute for both: centers and coordinates
+// However, I though this would only be executed in non-parallel sections
 int contcenters(Points *points)
 {
-  long i, ii;
-  float relweight;
+    long i, ii;
+    float relweight;
 
-  for (i=0;i<points->num;i++) {
-    /* compute relative weight of this point to the cluster */
-    if (points->p[i].assign != i) {
-      relweight=points->p[points->p[i].assign].weight + points->p[i].weight;
-      relweight = points->p[i].weight/relweight;
-      for (ii=0;ii<points->dim;ii++) {
-	points->p[points->p[i].assign].coord[ii]*=1.0-relweight;
-	points->p[points->p[i].assign].coord[ii]+=
-	  points->p[i].coord[ii]*relweight;
-      }
-      points->p[points->p[i].assign].weight += points->p[i].weight;
-    }
-  }
-  
-  return 0;
+    for (i=0;i<points->num;i++) {
+        /* compute relative weight of this point to the cluster */
+        if (points->p[i].assign != i) {
+            relweight=points->p[points->p[i].assign].weight + points->p[i].weight;
+            relweight = points->p[i].weight/relweight;
+            for (ii=0;ii<points->dim;ii++) {
+
+                // XXX Another write
+
+                long atmp = points->p[i].assign;
+                float ftmp = SK_P(points->p[atmp].coord_idx)[ii];
+
+                ftmp*=1.0-relweight;
+                ftmp+=
+                    SK_P(points->p[i].coord_idx)[ii]*relweight;
+
+                SK_P(points->p[atmp].coord_idx)[ii] = ftmp;
+            }
+            points->p[points->p[i].assign].weight += points->p[i].weight;
+        }
+    }
+
+    return 0;
 }
 
 /* copy centers from points to centers */
 void copycenters(Points *points, Points* centers, long* centerIDs, long offset)
 {
-  long i;
-  long k;
+    long i;
+    long k;
+
+    bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));
+
+    /* mark the centers */
+    for ( i = 0; i < points->num; i++ ) {
+        is_a_median[points->p[i].assign] = 1;
+    }
 
-  bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));
+    k=centers->num;
 
-  /* mark the centers */
-  for ( i = 0; i < points->num; i++ ) {
-    is_a_median[points->p[i].assign] = 1;
-  }
+    /* count how many  */
+    for ( i = 0; i < points->num; i++ ) {
+        if ( is_a_median[i] ) {
 
-  k=centers->num;
+            // XXX write
 
-  /* count how many  */
-  for ( i = 0; i < points->num; i++ ) {
-    if ( is_a_median[i] ) {
-      memcpy( centers->p[k].coord, points->p[i].coord, points->dim * sizeof(float));
-      centers->p[k].weight = points->p[i].weight;
-      centerIDs[k] = i + offset;
-      k++;
+            memcpy(centers->p[k].coord,
+                    SK_P(points->p[i].coord_idx), points->dim * sizeof(float));
+
+            centers->p[k].weight = points->p[i].weight;
+            centerIDs[k] = i + offset;
+            k++;
+        }
     }
-  }
 
-  centers->num = k;
+    centers->num = k;
 
-  free(is_a_median);
+    free(is_a_median);
 }
 
 struct pkmedian_arg_t
 {
-  Points* points;
-  long kmin;
-  long kmax;
-  long* kfinal;
-  int pid;
-  pthread_barrier_t* barrier;
+    Points* points;
+    long kmin;
+    long kmax;
+    long* kfinal;
+    int pid;
+    bool indirection;
+    pthread_barrier_t* barrier;
 };
 
 void* localSearchSub(void* arg_) {
 
-  pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;
-  pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);
+    pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;
 
-  return NULL;
-}
+#ifdef SC_REPLICATION
+    if (arg->indirection) {
+        //    printf("Thread %2d using replica %2d\n", arg->pid, replica_lookup[arg->pid]);
+        sk_block_a = sk_block_accessors[replica_lookup[arg->pid]];
+    } else {
+        sk_block_a = sk_center_org;
+    }
+#endif
+
+#ifdef SK_BIND
+#ifdef ENABLE_THREADS
+    shl__bind_processor_aff(arg->pid);
+#endif
+#endif
 
-#ifdef TBB_VERSION
-void localSearch( Points* points, long kmin, long kmax, long* kfinal ) {
-  pkmedian_arg_t arg;
-  arg.points = points;
-  arg.kmin = kmin;
-  arg.kmax = kmax;
-  arg.pid = 0;
-  arg.kfinal = kfinal;
-  localSearchSub(&arg);
+    shl__init_thread(arg->pid);
+
+    pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);
+
+    return NULL;
 }
-#else //!TBB_VERSION
 
-void localSearch( Points* points, long kmin, long kmax, long* kfinal ) {
+void localSearch( Points* points, long kmin, long kmax, long* kfinal, bool use_indirection ) {
     pthread_barrier_t barrier;
     pthread_t* threads = new pthread_t[nproc];
     pkmedian_arg_t* arg = new pkmedian_arg_t[nproc];
 
+    papi_start();
 #ifdef ENABLE_THREADS
     pthread_barrier_init(&barrier,NULL,nproc);
 #endif
     for( int i = 0; i < nproc; i++ ) {
-      arg[i].points = points;
-      arg[i].kmin = kmin;
-      arg[i].kmax = kmax;
-      arg[i].pid = i;
-      arg[i].kfinal = kfinal;
+        arg[i].points = points;
+        arg[i].kmin = kmin;
+        arg[i].kmax = kmax;
+        arg[i].pid = i;
+        arg[i].kfinal = kfinal;
+        arg[i].indirection = use_indirection;
 
-      arg[i].barrier = &barrier;
+        arg[i].barrier = &barrier;
 #ifdef ENABLE_THREADS
-      pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);
+        pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);
 #else
-      localSearchSub(&arg[0]);
+        localSearchSub(&arg[0]);
 #endif
     }
 
 #ifdef ENABLE_THREADS
     for ( int i = 0; i < nproc; i++) {
-      pthread_join(threads[i],NULL);
+        pthread_join(threads[i],NULL);
     }
 #endif
+    papi_stop();
 
     delete[] threads;
     delete[] arg;
@@ -1742,302 +967,369 @@ void localSearch( Points* points, long k
     pthread_barrier_destroy(&barrier);
 #endif
 }
-#endif // TBB_VERSION
-
 
 class PStream {
 public:
-  virtual size_t read( float* dest, int dim, int num ) = 0;
-  virtual int ferror() = 0;
-  virtual int feof() = 0;
-  virtual ~PStream() {
-  }
+    virtual size_t read( float* dest, int dim, int num ) = 0;
+    virtual int ferror() = 0;
+    virtual int feof() = 0;
+    virtual ~PStream() {
+    }
 };
 
 //synthetic stream
 class SimStream : public PStream {
 public:
-  SimStream(long n_ ) {
-    n = n_;
-  }
-  size_t read( float* dest, int dim, int num ) {
-    size_t count = 0;
-    for( int i = 0; i < num && n > 0; i++ ) {
-      for( int k = 0; k < dim; k++ ) {
-	dest[i*dim + k] = lrand48()/(float)INT_MAX;
-      }
-      n--;
-      count++;
-    }
-    return count;
-  }
-  int ferror() {
-    return 0;
-  }
-  int feof() {
-    return n <= 0;
-  }
-  ~SimStream() { 
-  }
+
+#ifdef SK_CRC_INPUT
+    crc_t crc;
+    FILE *fp;
+    const char* inputf;
+#endif
+    SimStream(long n_ ) {
+        n = n_;
+        printf("Generating points randomly .. \n");
+#ifdef SK_WRITE_INPUT
+        inputf = "/tmp/sc_input_native";
+        printf("Opening input file to write random coord [%s]\n", inputf);
+        fp = fopen(inputf, "wb");
+#endif
+#ifdef SK_CRC_INPUT
+        crc = crc_init();
+#endif
+    }
+    size_t read( float* dest, int dim, int num ) {
+        size_t count = 0;
+        for( int i = 0; i < num && n > 0; i++ ) {
+            for( int k = 0; k < dim; k++ ) {
+                dest[i*dim + k] = lrand48()/(float)INT_MAX;
+            }
+            n--;
+            count++;
+        }
+#ifdef SK_WRITE_INPUT
+        std::fwrite(dest, sizeof(float)*dim, num, fp);
+#endif
+#ifdef SK_CRC_INPUT
+        crc = crc_update(crc, (unsigned char*) dest, sizeof(float)*dim*num);
+#endif
+        return count;
+    }
+    int ferror() {
+        return 0;
+    }
+    int feof() {
+        return n <= 0;
+    }
+    ~SimStream() {
+#ifdef SK_CRC_INPUT
+        crc = crc_finalize(crc);
+        printf("0x%lx\n", (unsigned long)crc);
+#endif
+#ifdef SK_WRITE_INPUT
+        fclose(fp);
+#endif
+    }
 private:
-  long n;
+    long n;
 };
 
 class FileStream : public PStream {
 public:
-  FileStream(char* filename) {
-    fp = fopen( filename, "rb");
-    if( fp == NULL ) {
-      fprintf(stderr,"error opening file %s\n.",filename);
-      exit(1);
-    }
-  }
-  size_t read( float* dest, int dim, int num ) {
-    return std::fread(dest, sizeof(float)*dim, num, fp); 
-  }
-  int ferror() {
-    return std::ferror(fp);
-  }
-  int feof() {
-    return std::feof(fp);
-  }
-  ~FileStream() {
-    fprintf(stderr,"closing file stream\n");
-    fclose(fp);
-  }
+#ifdef SK_CRC_INPUT
+    crc_t crc;
+#endif
+    FileStream(char* filename) {
+
+        printf("Reading points from file\n");
+
+#ifdef SK_CRC_INPUT
+        crc = crc_init();
+#endif
+        fp = fopen( filename, "rb");
+        if( fp == NULL ) {
+            fprintf(stderr,"error opening file %s\n.",filename);
+            exit(1);
+        }
+    }
+    size_t read( float* dest, int dim, int num ) {
+        size_t res = std::fread(dest, sizeof(float)*dim, num, fp);
+#ifdef SK_CRC_INPUT
+        crc = crc_update(crc, (unsigned char*) dest, sizeof(float)*dim*num);
+#endif
+        return res;
+    }
+    int ferror() {
+        return std::ferror(fp);
+    }
+    int feof() {
+        return std::feof(fp);
+    }
+    ~FileStream() {
+        fprintf(stderr,"closing file stream\n");
+#ifdef SK_CRC_INPUT
+        crc = crc_finalize(crc);
+        printf("0x%lx\n", (unsigned long)crc);
+#endif
+        fclose(fp);
+    }
 private:
-  FILE* fp;
+    FILE* fp;
 };
 
 void outcenterIDs( Points* centers, long* centerIDs, char* outfile ) {
-  FILE* fp = fopen(outfile, "w");
-  if( fp==NULL ) {
-    fprintf(stderr, "error opening %s\n",outfile);
-    exit(1);
-  }
-  int* is_a_median = (int*)calloc( sizeof(int), centers->num );
-  for( int i =0 ; i< centers->num; i++ ) {
-    is_a_median[centers->p[i].assign] = 1;
-  }
-
-  for( int i = 0; i < centers->num; i++ ) {
-    if( is_a_median[i] ) {
-      fprintf(fp, "%u\n", centerIDs[i]);
-      fprintf(fp, "%lf\n", centers->p[i].weight);
-      for( int k = 0; k < centers->dim; k++ ) {
-	fprintf(fp, "%lf ", centers->p[i].coord[k]);
-      }
-      fprintf(fp,"\n\n");
+    FILE* fp = fopen(outfile, "w");
+    if( fp==NULL ) {
+        fprintf(stderr, "error opening %s\n",outfile);
+        exit(1);
+    }
+    int* is_a_median = (int*)calloc( sizeof(int), centers->num );
+    for( int i =0 ; i< centers->num; i++ ) {
+        is_a_median[centers->p[i].assign] = 1;
+    }
+
+    for( int i = 0; i < centers->num; i++ ) {
+        if( is_a_median[i] ) {
+            fprintf(fp, "%lu\n", centerIDs[i]);
+            fprintf(fp, "%lf\n", centers->p[i].weight);
+            for( int k = 0; k < centers->dim; k++ ) {
+                // This only works on the master array, as updates are only done there
+                fprintf(fp, "%lf ", centers->p[i].coord[k]);
+            }
+            fprintf(fp,"\n\n");
+        }
     }
-  }
-  fclose(fp);
+    fclose(fp);
 }
 
-void streamCluster( PStream* stream, 
-		    long kmin, long kmax, int dim,
-		    long chunksize, long centersize, char* outfile )
+void streamCluster( PStream* stream,
+                    long kmin, long kmax, int dim,
+                    long chunksize, long centersize, char* outfile )
 {
+    float* block = (float*)malloc( chunksize*dim*sizeof(float) );
+    float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );
+    long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));
+
+    if( block == NULL ) {
+        fprintf(stderr,"not enough memory for a chunk!\n");
+        exit(1);
+    }
 
-#ifdef TBB_VERSION
-  float* block = (float*)memoryFloat.allocate( chunksize*dim*sizeof(float) );
-  float* centerBlock = (float*)memoryFloat.allocate(centersize*dim*sizeof(float) );
-  long* centerIDs = (long*)memoryLong.allocate(centersize*dim*sizeof(long));
-#else
-  float* block = (float*)malloc( chunksize*dim*sizeof(float) );
-  float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );
-  long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));
-#endif
-
-  if( block == NULL ) { 
-    fprintf(stderr,"not enough memory for a chunk!\n");
-    exit(1);
-  }
-
-  Points points;
-  points.dim = dim;
-  points.num = chunksize;
-  points.p = 
-#ifdef TBB_VERSION
-    (Point *)memoryPoint.allocate(chunksize*sizeof(Point), NULL);
-#else
+    Points points;
+    points.dim = dim;
+    points.num = chunksize;
+    points.p =
     (Point *)malloc(chunksize*sizeof(Point));
-#endif
-
-  for( int i = 0; i < chunksize; i++ ) {
-    points.p[i].coord = &block[i*dim];
-  }
-
-  Points centers;
-  centers.dim = dim;
-  centers.p = 
-#ifdef TBB_VERSION
-    (Point *)memoryPoint.allocate(centersize*sizeof(Point), NULL);
-#else
-    (Point *)malloc(centersize*sizeof(Point));
-#endif
-  centers.num = 0;
-
-  for( int i = 0; i< centersize; i++ ) {
-    centers.p[i].coord = &centerBlock[i*dim];
-    centers.p[i].weight = 1.0;
-  }
 
-  long IDoffset = 0;
-  long kfinal;
-  while(1) {
-
-    size_t numRead  = stream->read(block, dim, chunksize ); 
-    fprintf(stderr,"read %d points\n",numRead);
-
-    if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {
-      fprintf(stderr, "error reading data!\n");
-      exit(1);
+    // Set accessors
+    sk_block_a = block;
+    sk_center_org = centerBlock;
+    sk_block_org = block;
+
+    for( int i = 0; i < chunksize; i++ ) {
+        points.p[i].coord = &block[i*dim];
+        points.p[i].coord_idx = i*dim;
     }
 
-    points.num = numRead;
-    for( int i = 0; i < points.num; i++ ) {
-      points.p[i].weight = 1.0;
-    }
-
-#ifdef TBB_VERSION
-    switch_membership = (bool*)memoryBool.allocate(points.num*sizeof(bool), NULL);
-    is_center = (bool*)calloc(points.num,sizeof(bool));
-    center_table = (int*)memoryInt.allocate(points.num*sizeof(int));
-#else
-    switch_membership = (bool*)malloc(points.num*sizeof(bool));
-    is_center = (bool*)calloc(points.num,sizeof(bool));
-    center_table = (int*)malloc(points.num*sizeof(int));
-#endif
-
-
-    //fprintf(stderr,"center_table = 0x%08x\n",(int)center_table);
-    //fprintf(stderr,"is_center = 0x%08x\n",(int)is_center);
-
-    localSearch(&points,kmin, kmax,&kfinal); // parallel
+    Points centers;
+    centers.dim = dim;
+    centers.p =
+    (Point *)malloc(centersize*sizeof(Point));
+    centers.num = 0;
 
-    //fprintf(stderr,"finish local search\n");
-    contcenters(&points); /* sequential */
-    if( kfinal + centers.num > centersize ) {
-      //here we don't handle the situation where # of centers gets too large. 
-      fprintf(stderr,"oops! no more space for centers\n");
-      exit(1);
+    for( int i = 0; i< centersize; i++ ) {
+        centers.p[i].coord = &centerBlock[i*dim];
+        centers.p[i].coord_idx = i*dim;
+        centers.p[i].weight = 1.0;
     }
 
-    copycenters(&points, &centers, centerIDs, IDoffset); /* sequential */
-    IDoffset += numRead;
+    int skit = 0;
 
-#ifdef TBB_VERSION
-    memoryBool.deallocate(switch_membership, sizeof(bool));
-    free(is_center);
-    memoryInt.deallocate(center_table, sizeof(int));
-#else
-    free(is_center);
-    free(switch_membership);
-    free(center_table);
-#endif
+    long IDoffset = 0;
+    long kfinal;
+    while(1) {
 
-    if( stream->feof() ) {
-      break;
-    }
-  }
+        size_t numRead  = stream->read(block, dim, chunksize );
+        fprintf(stderr,"read %zu points\n",numRead);
 
-  //finally cluster all temp centers
-#ifdef TBB_VERSION
-  switch_membership = (bool*)memoryBool.allocate(centers.num*sizeof(bool));
-  is_center = (bool*)calloc(centers.num,sizeof(bool));
-  center_table = (int*)memoryInt.allocate(centers.num*sizeof(int));
-#else
-  switch_membership = (bool*)malloc(centers.num*sizeof(bool));
-  is_center = (bool*)calloc(centers.num,sizeof(bool));
-  center_table = (int*)malloc(centers.num*sizeof(int));
-#endif
+        int pagesize = -1;
 
-  localSearch( &centers, kmin, kmax ,&kfinal ); // parallel
-  contcenters(&centers);
-  outcenterIDs( &centers, centerIDs, outfile);
+#ifdef SC_REPLICATION
+        int num_replicas = -1;
+        int malloc_options = SHL_MALLOC_NONE;
+#ifdef SC_HUGEPAGE
+        malloc_options |= SHL_MALLOC_HUGEPAGE;
+#endif
+        assert(num_replicas<=0);
+        sk_block_accessors =
+            (float**) shl__malloc_replicated(chunksize*dim*sizeof(float),
+                                             &pagesize,
+                                             &num_replicas,
+                                             malloc_options, NULL);
+
+        printf("shl__repl_sync NOW .. \n");
+        shl__repl_sync(block, (void**) sk_block_accessors,
+                       num_replicas, chunksize*dim*sizeof(float));
+#endif
+
+        if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {
+            fprintf(stderr, "error reading data!\n");
+            exit(1);
+        }
+
+        // SK: fix: if no more points are read, abort
+        if (stream->feof() && numRead==0) {
+            fprintf(stderr, "no more points, aborting\n");
+            break;
+        }
+
+        points.num = numRead;
+        for( int i = 0; i < points.num; i++ ) {
+            points.p[i].weight = 1.0;
+        }
+
+        switch_membership = (bool*)malloc(points.num*sizeof(bool));
+        is_center = (bool*)calloc(points.num,sizeof(bool));
+        center_table = (int*)malloc(points.num*sizeof(int));
+
+        // Using points -> indirection
+        localSearch(&points, kmin, kmax,&kfinal, true); // parallel
+
+        //fprintf(stderr,"finish local search\n");
+        sk_block_a = sk_block_org; contcenters(&points); /* sequential */
+        if( kfinal + centers.num > centersize ) {
+            //here we don't handle the situation where # of centers gets too large.
+            fprintf(stderr,"oops! no more space for centers\n");
+            exit(1);
+        }
+
+        copycenters(&points, &centers, centerIDs, IDoffset); /* sequential */
+        IDoffset += numRead;
+
+        free(is_center);
+        free(switch_membership);
+        free(center_table);
+
+#ifdef SK_CRC_RUNTIME
+        // Print CRC for both, centers and blocks:
+        crc_t crc_b, crc_c;
+        crc_b = crc_init(); crc_c = crc_init();
+        crc_b = crc_update(crc_b, (unsigned char*) block, chunksize*dim*sizeof(float));
+        crc_c = crc_update(crc_c, (unsigned char*) centerBlock, centersize*dim*sizeof(float));
+        crc_b = crc_finalize(crc_b); crc_c = crc_finalize(crc_c);
+        printf("Iteration %d: centers=0x%lx points=0x%lx\n", skit++, crc_c, crc_b);
+#endif /* SK_CRC_RUNTIME */
+
+        if( stream->feof() ) {
+            break;
+        }
+
+    }
+
+    //finally cluster all temp centers
+    switch_membership = (bool*)malloc(centers.num*sizeof(bool));
+    is_center = (bool*)calloc(centers.num,sizeof(bool));
+    center_table = (int*)malloc(centers.num*sizeof(int));
+
+    printf("localSearch .. \n");
+    // using centers -> NO indirection
+    localSearch( &centers, kmin, kmax ,&kfinal, false ); // parallel
+    printf("contcenters .. \n");
+    sk_block_a = sk_center_org; contcenters(&centers);
+    printf("outcenterIDs .. \n");
+    outcenterIDs( &centers, centerIDs, outfile);
+
+#ifdef SK_CRC_RUNTIME
+    // Print CRC for both, centers and blocks:
+    crc_t crc_b, crc_c;
+    crc_b = crc_init(); crc_c = crc_init();
+    crc_b = crc_update(crc_b, (unsigned char*) block, chunksize*dim*sizeof(float));
+    crc_c = crc_update(crc_c, (unsigned char*) centerBlock, centersize*dim*sizeof(float));
+    crc_b = crc_finalize(crc_b); crc_c = crc_finalize(crc_c);
+    printf("Iteration %d: centers=0x%lx points=0x%lx\n", skit++, crc_c, crc_b);
+#endif /* SK_CRC_RUNTIME */
 }
 
 int main(int argc, char **argv)
 {
-  char *outfilename = new char[MAXNAMESIZE];
-  char *infilename = new char[MAXNAMESIZE];
-  long kmin, kmax, n, chunksize, clustersize;
-  int dim;
+    assert (sizeof(uintptr_t)==8);
+
+    char *outfilename = new char[MAXNAMESIZE];
+    char *infilename = new char[MAXNAMESIZE];
+    long kmin, kmax, n, chunksize, clustersize;
+    int dim;
 
 #ifdef PARSEC_VERSION
 #define __PARSEC_STRING(x) #x
 #define __PARSEC_XSTRING(x) __PARSEC_STRING(x)
-        fprintf(stderr,"PARSEC Benchmark Suite Version "__PARSEC_XSTRING(PARSEC_VERSION)"\n");
+    fprintf(stderr,"PARSEC Benchmark Suite Version "__PARSEC_XSTRING(PARSEC_VERSION)"\n");
 	fflush(NULL);
 #else
-        fprintf(stderr,"PARSEC Benchmark Suite\n");
+    fprintf(stderr,"PARSEC Benchmark Suite\n");
 	fflush(NULL);
 #endif //PARSEC_VERSION
 #ifdef ENABLE_PARSEC_HOOKS
-  __parsec_bench_begin(__parsec_streamcluster);
+    __parsec_bench_begin(__parsec_streamcluster);
 #endif
 
-  if (argc<10) {
-    fprintf(stderr,"usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n",
-	    argv[0]);
-    fprintf(stderr,"  k1:          Min. number of centers allowed\n");
-    fprintf(stderr,"  k2:          Max. number of centers allowed\n");
-    fprintf(stderr,"  d:           Dimension of each data point\n");
-    fprintf(stderr,"  n:           Number of data points\n");
-    fprintf(stderr,"  chunksize:   Number of data points to handle per step\n");
-    fprintf(stderr,"  clustersize: Maximum number of intermediate centers\n");
-    fprintf(stderr,"  infile:      Input file (if n<=0)\n");
-    fprintf(stderr,"  outfile:     Output file\n");
-    fprintf(stderr,"  nproc:       Number of threads to use\n");
-    fprintf(stderr,"\n");
-    fprintf(stderr, "if n > 0, points will be randomly generated instead of reading from infile.\n");
-    exit(1);
-  }
-
-
-
-  kmin = atoi(argv[1]);
-  kmax = atoi(argv[2]);
-  dim = atoi(argv[3]);
-  n = atoi(argv[4]);
-  chunksize = atoi(argv[5]);
-  clustersize = atoi(argv[6]);
-  strcpy(infilename, argv[7]);
-  strcpy(outfilename, argv[8]);
-  nproc = atoi(argv[9]);
-
-
-#ifdef TBB_VERSION
-  fprintf(stderr,"TBB version. Number of divisions: %d\n",NUM_DIVISIONS);
-  tbb::task_scheduler_init init(nproc);
-#endif
-
-
-  srand48(SEED);
-  PStream* stream;
-  if( n > 0 ) {
-    stream = new SimStream(n);
-  }
-  else {
-    stream = new FileStream(infilename);
-  }
+    // Input for native:
+    // 10 20 - 128 0 - 200000 5000
 
+    if (argc<10) {
+        fprintf(stderr,"usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n",
+                argv[0]);
+        fprintf(stderr,"  k1:          Min. number of centers allowed\n");
+        fprintf(stderr,"  k2:          Max. number of centers allowed\n");
+        fprintf(stderr,"  d:           Dimension of each data point\n");
+        fprintf(stderr,"  n:           Number of data points\n");
+        fprintf(stderr,"  chunksize:   Number of data points to handle per step\n");
+        fprintf(stderr,"  clustersize: Maximum number of intermediate centers\n");
+        fprintf(stderr,"  infile:      Input file (if n<=0)\n");
+        fprintf(stderr,"  outfile:     Output file\n");
+        fprintf(stderr,"  nproc:       Number of threads to use\n");
+        fprintf(stderr,"\n");
+        fprintf(stderr, "if n > 0, points will be randomly generated instead of reading from infile.\n");
+        exit(1);
+    }
+
+    kmin = atoi(argv[1]);
+    kmax = atoi(argv[2]);
+    dim = atoi(argv[3]);
+    n = atoi(argv[4]);
+    chunksize = atoi(argv[5]);
+    clustersize = atoi(argv[6]);
+    strcpy(infilename, argv[7]);
+    strcpy(outfilename, argv[8]);
+    nproc = atoi(argv[9]);
+
+    shl__init(nproc,false);
+
+    srand48(SEED);
+    PStream* stream;
+    if( n > 0 ) {
+        stream = new SimStream(n);
+    }
+    else {
+        stream = new FileStream(infilename);
+    }
 
 #ifdef ENABLE_PARSEC_HOOKS
-  __parsec_roi_begin();
+    __parsec_roi_begin();
 #endif
 
-  streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );
+    shl__start_timer(0);
+    streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );
+    printf("Runtime: %f\n", shl__end_timer("runtime"));
 
 #ifdef ENABLE_PARSEC_HOOKS
-  __parsec_roi_end();
+    __parsec_roi_end();
 #endif
 
-  delete stream;
+    delete stream;
 
 #ifdef ENABLE_PARSEC_HOOKS
-  __parsec_bench_end();
+    __parsec_bench_end();
 #endif
-  
-  return 0;
+
+    return 0;
 }
diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/streamcluster.patch ./streamcluster.patch
--- /home/skaestle/Desktop/shl-sc/streamcluster/streamcluster.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./streamcluster.patch	2015-06-23 11:30:33.030293981 +0200
@@ -0,0 +1,3305 @@
+diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/crc.c ./crc.c
+--- /home/skaestle/Desktop/shl-sc/streamcluster/crc.c	1970-01-01 01:00:00.000000000 +0100
++++ ./crc.c	2014-07-21 10:47:32.417694098 +0200
+@@ -0,0 +1,100 @@
++/**
++ * \file crc.c
++ * Functions and types for CRC checks.
++ *
++ * Generated on Wed Jul  9 21:15:38 2014,
++ * by pycrc v0.8.1, http://www.tty1.net/pycrc/
++ * using the configuration:
++ *    Width        = 16
++ *    Poly         = 0x8005
++ *    XorIn        = 0x0000
++ *    ReflectIn    = True
++ *    XorOut       = 0x0000
++ *    ReflectOut   = True
++ *    Algorithm    = table-driven
++ *****************************************************************************/
++#include "crc.h"     /* include the header file generated with pycrc */
++#include <stdlib.h>
++#include <stdint.h>
++
++/**
++ * Static table used for the table_driven implementation.
++ *****************************************************************************/
++static const crc_t crc_table[256] = {
++    0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
++    0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
++    0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
++    0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
++    0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
++    0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
++    0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
++    0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
++    0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
++    0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
++    0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
++    0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
++    0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
++    0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
++    0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
++    0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
++    0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
++    0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
++    0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
++    0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
++    0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
++    0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
++    0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
++    0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
++    0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
++    0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
++    0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
++    0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
++    0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
++    0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
++    0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
++    0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
++};
++
++/**
++ * Reflect all bits of a \a data word of \a data_len bytes.
++ *
++ * \param data         The data word to be reflected.
++ * \param data_len     The width of \a data expressed in number of bits.
++ * \return             The reflected data.
++ *****************************************************************************/
++crc_t crc_reflect(crc_t data, size_t data_len)
++{
++    unsigned int i;
++    crc_t ret;
++
++    ret = data & 0x01;
++    for (i = 1; i < data_len; i++) {
++        data >>= 1;
++        ret = (ret << 1) | (data & 0x01);
++    }
++    return ret;
++}
++
++
++/**
++ * Update the crc value with new data.
++ *
++ * \param crc      The current crc value.
++ * \param data     Pointer to a buffer of \a data_len bytes.
++ * \param data_len Number of bytes in the \a data buffer.
++ * \return         The updated crc value.
++ *****************************************************************************/
++crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len)
++{
++    unsigned int tbl_idx;
++
++    while (data_len--) {
++        tbl_idx = (crc ^ *data) & 0xff;
++        crc = (crc_table[tbl_idx] ^ (crc >> 8)) & 0xffff;
++
++        data++;
++    }
++    return crc & 0xffff;
++}
++
++
+diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/crc.h ./crc.h
+--- /home/skaestle/Desktop/shl-sc/streamcluster/crc.h	1970-01-01 01:00:00.000000000 +0100
++++ ./crc.h	2014-07-21 10:47:32.417694098 +0200
+@@ -0,0 +1,89 @@
++/**
++ * \file crc.h
++ * Functions and types for CRC checks.
++ *
++ * Generated on Wed Jul  9 21:15:42 2014,
++ * by pycrc v0.8.1, http://www.tty1.net/pycrc/
++ * using the configuration:
++ *    Width        = 16
++ *    Poly         = 0x8005
++ *    XorIn        = 0x0000
++ *    ReflectIn    = True
++ *    XorOut       = 0x0000
++ *    ReflectOut   = True
++ *    Algorithm    = table-driven
++ *****************************************************************************/
++#ifndef __CRC_H__
++#define __CRC_H__
++
++#include <stdlib.h>
++#include <stdint.h>
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++
++/**
++ * The definition of the used algorithm.
++ *****************************************************************************/
++#define CRC_ALGO_TABLE_DRIVEN 1
++
++
++/**
++ * The type of the CRC values.
++ *
++ * This type must be big enough to contain at least 16 bits.
++ *****************************************************************************/
++typedef uint_fast16_t crc_t;
++
++
++/**
++ * Reflect all bits of a \a data word of \a data_len bytes.
++ *
++ * \param data         The data word to be reflected.
++ * \param data_len     The width of \a data expressed in number of bits.
++ * \return             The reflected data.
++ *****************************************************************************/
++crc_t crc_reflect(crc_t data, size_t data_len);
++
++
++/**
++ * Calculate the initial crc value.
++ *
++ * \return     The initial crc value.
++ *****************************************************************************/
++static inline crc_t crc_init(void)
++{
++    return 0x0000;
++}
++
++
++/**
++ * Update the crc value with new data.
++ *
++ * \param crc      The current crc value.
++ * \param data     Pointer to a buffer of \a data_len bytes.
++ * \param data_len Number of bytes in the \a data buffer.
++ * \return         The updated crc value.
++ *****************************************************************************/
++crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len);
++
++
++/**
++ * Calculate the final crc value.
++ *
++ * \param crc  The current crc value.
++ * \return     The final crc value.
++ *****************************************************************************/
++static inline crc_t crc_finalize(crc_t crc)
++{
++    return crc ^ 0x0000;
++}
++
++
++#ifdef __cplusplus
++}           /* closing brace for extern "C" */
++#endif
++
++#endif      /* __CRC_H__ */
+diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/Makefile ./Makefile
+--- /home/skaestle/Desktop/shl-sc/streamcluster/Makefile	2015-06-23 11:17:22.546771791 +0200
++++ ./Makefile	2015-06-23 11:20:53.525624020 +0200
+@@ -2,30 +2,86 @@
+ 
+ PREFIX=${PARSECDIR}/pkgs/kernels/streamcluster/inst/${PARSECPLAT}
+ 
++BASE = $(HOME)/projects/gm/
++SHLPREFIX = $(BASE)/shoal/
++
+ TARGET=streamcluster
+ OBJS=streamcluster.o
+ 
+-ifdef version
+-  ifeq "$(version)" "pthreads"
+-    CXXFLAGS :=	$(CXXFLAGS) -DENABLE_THREADS -pthread
+-    OBJS += parsec_barrier.o
+-  endif
+-  ifeq "$(version)" "tbb"
+-    CXXFLAGS := $(CXXFLAGS) -DTBB_VERSION
+-    LIBS := $(LIBS) -ltbb
+-  endif
++CXXFLAGS := $(CXXFLAGS) -DENABLE_THREADS -pthread
++OBJS += parsec_barrier.o crc.o $(SHLPREFIX)/src/misc.o $(SHLPREFIX)/src/linux.o $(SHLPREFIX)/src/shl.o
++
++GIT_VERSION := $(shell git describe --abbrev=4 --dirty --always)
++
++#BUILDTYPE := debug
++BUILDTYPE := release
++
++all: streamcluster
++
++# --------------------------------------------------
++# Shoal integration >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
++
++# Path informations
++ROOT := $(shell pwd)
++BASE := $(ROOT)/shoal/
++SHOAL := $(BASE)/shoal/
++LUA := $(BASE)/contrib/lua-5.2.3/src/
++
++INC := \
++	-I$(BASE)contrib/numactl-2.0.9 \
++	-I$(SHOAL)/inc \
++	-I$(BASE)contrib/papi-5.3.0/src \
++	-I$(BASE)contrib/pycrc \
++	-I$(LUA)
++
++LIB := \
++	-L$(BASE)contrib/numactl-2.0.9 -lnuma \
++	-L$(BASE)contrib/papi-5.3.0/src -lpapi \
++	-L$(BASE)contrib/papi-5.3.0/src/libpfm4/lib -lpfm \
++	-L$(SHOAL) -lshl \
++	-L$(LUA)/liblua.a -lm -ldl
++
++ifeq ($(BUILDTYPE),debug)
++	CXXFLAGS +=-g -O0 -pg -DSHL_DEBUG
++else
++	CXXFLAGS += -O3
+ endif
+ 
+-all: $(OBJS)
++CXXFLAGS += -std=gnu++0x
++
++CXXFLAGS += $(INC) -DVERSION=\"$(GIT_VERSION)\" -fopenmp
++LIBS += $(LIB)
++
++# Helpers to build libshoal
++# ------------------------------
++
++LIBSHOAL := $(SHOAL)/libshl.so
++
++# Recursively build libshoal
++.PHONY: $(LIBSHOAL)
++$(LIBSHOAL):
++	$(MAKE) -C $(SHOAL) BUILDTYPE=$(BUILDTYPE)
++
++sk_clean:
++	$(MAKE) -C $(SHOAL) clean
++
++# END Shoal integration <<<<<<<<<<<<<<<<<<<<<<<<<<<<
++# --------------------------------------------------
++
++.PHONY: streamcluster
++streamcluster: $(LIBSHOAL) | $(OBJS)
+ 	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(OBJS) $(LIBS) -o $(TARGET)
+ 
+ %.o : %.cpp
+ 	$(CXX) $(CXXFLAGS) -c $<
+ 
++%.o : %.c
++	$(CXX) $(CXXFLAGS) -c $< -o $@
++
+ clean:
+ 	rm -f *.o $(TARGET)
++	$(MAKE) -C $(SHLPREFIX) clean
+ 
+ install:
+ 	mkdir -p $(PREFIX)/bin
+ 	cp -f $(TARGET) $(PREFIX)/bin/$(TARGET)
+-
+diff -rupN /home/skaestle/Desktop/shl-sc/streamcluster/streamcluster.cpp ./streamcluster.cpp
+--- /home/skaestle/Desktop/shl-sc/streamcluster/streamcluster.cpp	2015-06-23 11:17:22.546771791 +0200
++++ ./streamcluster.cpp	2015-06-23 11:20:53.529624076 +0200
+@@ -15,21 +15,64 @@
+ #include <math.h>
+ #include <sys/resource.h>
+ #include <limits.h>
++#include <shl.h>
++
++// --------------------------------------------------
++// CONFIGURATION
++// --------------------------------------------------
++
++// Write randomly generated coordiantes to file
++//#define SK_WRITE_INPUT
++
++// Calculate and print CRC on coordinates
++// These are either read from file or generated automatically
++#define SK_CRC_INPUT
++
++// Caculate the CRC of centers and blocks for every chunk + end
++#define SK_CRC_RUNTIME
++
++// Bind threads to cores
++#define SK_BIND
++
++// Replicate arrays
++#define SC_REPLICATION
++
++// Use huge pages for arrays (need machine support)
++//#define SC_HUGEPAGE
++
++// --------------------------------------------------
++// STATE
++// --------------------------------------------------
++
++// Per thread:
++
++// We need an "accessor" for the block array
++#ifdef SC_REPLICATION
++// Thread-local accessor used in SK_P macro
++__thread float *sk_block_a;
++// Pointer to all replicas
++float **sk_block_accessors;
++// We use *_org to point to the original arrays
++float *sk_center_org;
++float *sk_block_org;
++#else
++float *sk_block_a;
++float *sk_center_a;
++#endif
++
++// --------------------------------------------------
++// --------------------------------------------------
+ 
+ #ifdef ENABLE_THREADS
+ #include <pthread.h>
+ #include "parsec_barrier.hpp"
++
+ #endif
+ 
+-#ifdef TBB_VERSION
+-#define TBB_STEALER (tbb::task_scheduler_init::occ_stealer)
+-#define NUM_DIVISIONS (nproc)
+-#include "tbb/task_scheduler_init.h"
+-#include "tbb/blocked_range.h"
+-#include "tbb/parallel_for.h"
+-#include "tbb/parallel_reduce.h"
+-#include "tbb/cache_aligned_allocator.h"
+-using namespace tbb;
++#ifdef SK_CRC_INPUT
++extern "C" {
++#include "crc.h"
++}
+ #endif
+ 
+ #ifdef ENABLE_PARSEC_HOOKS
+@@ -47,24 +90,25 @@ using namespace std;
+ 
+ /* higher ITER --> more likely to get correct # of centers */
+ /* higher ITER also scales the running time almost linearly */
+-#define ITER 3 // iterate ITER* k log k times; ITER >= 1
++#define ITER 10 // iterate ITER* k log k times; ITER >= 1
+ 
+ #define CACHE_LINE 32 // cache line in byte
+ 
+ /* this structure represents a point */
+ /* these will be passed around to avoid copying coordinates */
+ typedef struct {
+-  float weight;
+-  float *coord;
+-  long assign;  /* number of point where this one is assigned */
+-  float cost;  /* cost of that assignment, weight*distance */
++    float weight;
++    float *coord;
++    uintptr_t coord_idx;
++    long assign;  /* number of point where this one is assigned */
++    float cost;  /* cost of that assignment, weight*distance */
+ } Point;
+ 
+ /* this is the array of points */
+ typedef struct {
+-  long num; /* number of points; may not be N if this is a sample */
+-  int dim;  /* dimensionality */
+-  Point *p; /* the array itself */
++    long num; /* number of points; may not be N if this is a sample */
++    int dim;  /* dimensionality */
++    Point *p; /* the array itself */
+ } Points;
+ 
+ static bool *switch_membership; //whether to switch membership in pgain
+@@ -74,1095 +118,429 @@ static int* center_table; //index table
+ static int nproc; //# of threads
+ 
+ 
+-#ifdef TBB_VERSION
+-tbb::cache_aligned_allocator<float> memoryFloat;
+-tbb::cache_aligned_allocator<Point> memoryPoint;
+-tbb::cache_aligned_allocator<long> memoryLong;
+-tbb::cache_aligned_allocator<int> memoryInt;
+-tbb::cache_aligned_allocator<bool> memoryBool;
+-#endif
+-
+-
+ float dist(Point p1, Point p2, int dim);
+ 
+-
+-#ifdef TBB_VERSION
+-struct HizReduction {
+-private:
+-  double hiz;
+-public:
+-  Points *points;
+-  HizReduction(Points *points_): hiz(0),points(points_){}
+-  HizReduction( HizReduction &d, tbb::split){hiz=0; points = d.points;}
+-
+-  void operator()(const tbb::blocked_range<int>& range) {
+-    double myhiz = 0;
+-    long ptDimension = points->dim;
+-    int begin = range.begin();
+-    int end = range.end();
+-    
+-    for(int kk=begin; kk!=end; kk++) {
+-      myhiz += dist(points->p[kk], points->p[0],
+-			 ptDimension)*points->p[kk].weight;
+-    }
+-    hiz += myhiz;
+-  }
+-
+-  void join(HizReduction &d){hiz += d.getHiz(); /*fprintf(stderr,"reducing: %lf\n",hiz);*/}
+-  double getHiz(){return hiz;}
+-
+-};
+-
+-
+-struct CenterCreate {
+-  Points *points;
+-  CenterCreate(Points *p): points(p){}
+-  void operator()(const tbb::blocked_range<int>&range) const {
+-    int begin = range.begin();
+-    int end = range.end();
+-    
+-     for( int k = begin; k!=end; k++ )    {
+-       float distance = dist(points->p[k],points->p[0],points->dim);
+-       points->p[k].cost = distance * points->p[k].weight;
+-       points->p[k].assign=0;
+-     } 
+-  }
+-
+-};
+-
+-
+-
+-struct CenterOpen {
+-private:
+-  double total_cost;
+-public:
+-  Points *points;
+-  int i;
+-  int type; /*type=0: compute. type=1: reduction */
+-  CenterOpen(Points *p):points(p),total_cost(0),type(0){}
+-  CenterOpen(CenterOpen &rhs, tbb::split) 
+-  {
+-    total_cost = 0; 
+-    points = rhs.points;
+-    i = rhs.i;
+-    type = rhs.type;
+-  }
+-
+-  void operator()(const tbb::blocked_range<int> &range) {
+-    int begin = range.begin();
+-    int end = range.end();
+-
+-    if(type) {
+-      double local_total = 0.0;
+-      for(int k = begin; k!=end; k++ )  
+-	local_total+=points->p[k].cost;
+-      total_cost += local_total;
+-    }
+-    else {
+-      for(int k = begin; k!=end; k++ )  {
+-	float distance = dist(points->p[i],points->p[k],points->dim);
+-	if( i && distance*points->p[k].weight < points->p[k].cost )  {
+-	  points->p[k].cost = distance * points->p[k].weight;
+-	  points->p[k].assign=i;
+-	}
+-      }
+-    }
+-    
+-  }
+-
+-
+-  void join(CenterOpen &lhs){total_cost+=lhs.getTotalCost();}
+-  double getTotalCost(){return total_cost;}
+-
+-};
+-
+-
+-
+-class CenterTableCount: public tbb::task{
+-private:
+-  Points *points;
+-  double *work_mem;
+-  int stride;
+-  int pid;
+-public:
+-  CenterTableCount(int id, int s, Points *p, double *mem):
+-    pid(id), stride(s), points(p),work_mem(mem){}
+-
+-  task *execute() {
+-    int count = 0;
+-    long bsize = points->num/((NUM_DIVISIONS));
+-    long k1 = bsize * pid;
+-    long k2 = k1 + bsize;
+-
+-    if( pid == (NUM_DIVISIONS)-1 ) 
+-      k2 = points->num;
+-
+-    /* fprintf(stderr,"\t[CenterTableCount]: pid=%d stride=%d from %d to %d\n",
+-       pid, stride, k1, k2); */
+-
+-    for( int i = k1; i < k2; i++ ) {
+-      if( is_center[i] ) {
+-	center_table[i] = count++;
+-      }
+-    }
+-
+-    work_mem[pid*stride] = count;
+-    //fprintf(stderr,"PID %d done!\n",pid);
+-    return NULL;
+-  }
+-
+-};
+-
+-
+-class CenterTableCountTask: public tbb::task {
+-  int is_continuation;
+-  Points *points;
+-  double *work_mem;
+-  int stride;
+-public:
+-  CenterTableCountTask(int s, Points *p, double *mem):
+-    stride(s), points(p), work_mem(mem), is_continuation(0){} 
+-
+-  task *execute() {
+-    tbb::task_list list;
+-    int p;
+-    
+-    if(!is_continuation) {
+-      recycle_as_continuation();
+-      set_ref_count(NUM_DIVISIONS);
+-
+-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
+-	  list.push_back( *new( allocate_child() ) CenterTableCount(p, stride, points, work_mem));
+-      CenterTableCount &me = *new( allocate_child() ) CenterTableCount(0, stride, points, work_mem);
+-      spawn(list);
+-      is_continuation = 1;
+-      
+-      return &me;
+-
+-    }else {
+-      /* continuation part */
+-      int accum = 0;
+-      for( int p = 0; p < (NUM_DIVISIONS); p++ ) {
+-	int tmp = (int)work_mem[p*stride];
+-	work_mem[p*stride] = accum;
+-	accum += tmp;
+-      }
+-      //fprintf(stderr,"Accum = %d\n",accum);
+-      return NULL;
+-    }
+-  }
+-};
+-
+-
+-class FixCenter: public tbb::task {
+-  Points *points;
+-  double *work_mem;
+-  int pid;
+-  int stride;
+-public:
+-  FixCenter(int id, int s, Points *p, double *mem):
+-    pid(id),stride(s),points(p),work_mem(mem){}
+-  task *execute(){
+-#ifdef SERIAL_FIXCENTER
+-    long k1 = 0;
+-    long k2 = points->num;
+-#else    
+-    long bsize = points->num/((NUM_DIVISIONS));
+-    long k1 = bsize * pid;
+-    long k2 = k1 + bsize;
+-    if( pid == (NUM_DIVISIONS)-1 ) k2 = points->num;
+-#endif
+-    /*fprintf(stderr,"\t[FixCenter]: pid=%d stride=%d from %d to %d is_center=0x%08x\n",
+-      pid, stride, k1, k2,(int)is_center);  */
+-    
+-    for( int i = k1; i < k2; i++ ) {
+-      if( is_center[i] ) {
+-	center_table[i] += (int)work_mem[pid*stride];
+-	//fprintf(stderr,"\tcenter_table[%d] = %d\n",i,center_table[i]);
+-      }
+-
+-    }
+-      //fprintf(stderr,"PID %d done!\n",pid);
+-    return NULL;
+-
+-  }
+-};
+-
+-class FixCenterTask: public tbb::task {
+-  bool is_continuation;
+-  Points *points;
+-  double *work_mem;
+-  int stride;
+-public:
+-  FixCenterTask(int s, Points *p, double *mem):
+-    stride(s), points(p), work_mem(mem), is_continuation(false){} 
+-
+-  task *execute() {
+-    tbb::task_list list;
+-    int p;
+-    if(!is_continuation) {
+-      recycle_as_continuation();
+-      set_ref_count(NUM_DIVISIONS);
+-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
+-	  list.push_back( *new( allocate_child() ) FixCenter(p, stride, points, work_mem));
+-      spawn(list);
+-      FixCenter &me = *new (allocate_child()) FixCenter(0, stride, points, work_mem);
+-      is_continuation = true;
+-      return &me;
+-    }else {
+-      /* coninuation */
+-      return NULL;
+-    }
+-  }
+-};
+-
+-
+-class LowerCost: public tbb::task {
+-  Points *points;
+-  double *work_mem;
+-  long x;
+-  int K;
+-  int pid;
+-  int stride;
+-public:
+-  LowerCost(int id, int s, Points *p, long x_, double *mem, int k): 
+-    pid(id), stride(s), points(p), work_mem(mem), K(k), x(x_){}
+-  task *execute() {
+-
+-    //my *lower* fields
+-    double* lower = &work_mem[pid*stride];
+-    double local_cost_of_opening_x = 0;
+-    long bsize = points->num/((NUM_DIVISIONS)); //points->num/1;//((NUM_DIVISIONS));
+-    long k1 = bsize * pid;
+-    long k2 = k1 + bsize;
+-    int i;
+-
+-    if( pid == (NUM_DIVISIONS)-1 ) 
+-      k2 = points->num;
+-
+-
+-    /*fprintf(stderr,"\t[LowerCost]: pid=%d stride=%d from %d to %d\n",
+-      pid, stride, k1, k2);  */
+-    
+-    double *cost_of_opening_x = &work_mem[pid*stride + K+1];
+-
+-    for ( i = k1; i < k2; i++ ) {
+-      float x_cost = dist(points->p[i], points->p[x], points->dim) 
+-	* points->p[i].weight;
+-      float current_cost = points->p[i].cost;
+-
+-      //fprintf(stderr,"\t (x_cost=%lf < current_cost=%lf)\n",x_cost, current_cost);
+-      if ( x_cost < current_cost ) {
+-
+-	// point i would save cost just by switching to x
+-	// (note that i cannot be a median, 
+-	// or else dist(p[i], p[x]) would be 0)
+-	
+-	switch_membership[i] = 1;
+-	local_cost_of_opening_x += x_cost - current_cost;
+-	
+-      } else {
+-	
+-	// cost of assigning i to x is at least current assignment cost of i
+-	
+-	// consider the savings that i's **current** median would realize
+-	// if we reassigned that median and all its members to x;
+-	// note we've already accounted for the fact that the median
+-	// would save z by closing; now we have to subtract from the savings
+-	// the extra cost of reassigning that median and its members 
+-	int assign = points->p[i].assign;
+-	lower[center_table[assign]] += current_cost - x_cost;
+-	//fprintf(stderr,"Lower[%d]=%lf\n",center_table[assign], lower[center_table[assign]]);
+-      }
+-    }
+-    
+-    *cost_of_opening_x = local_cost_of_opening_x;
+-    return NULL;
+-  }
+-  
+-  
+-};
+-  
+-class LowerCostTask: public tbb::task {
+-  bool is_continuation;
+-  Points *points;
+-  double *work_mem;
+-  int K;
+-  long x;
+-  int stride;
+-public:
+-  LowerCostTask(int s, Points *p, long x_, double *mem, int k): 
+-    stride(s), points(p), work_mem(mem), K(k), x(x_), is_continuation(false){}
+-
+-  task *execute() {
+-    tbb::task_list list;
+-    int p;
+-    if(!is_continuation) {
+-      recycle_as_continuation();
+-      set_ref_count(NUM_DIVISIONS);
+-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
+-	  list.push_back( *new( allocate_child() )  LowerCost(p, stride, points, x, work_mem, K));
+-      spawn(list);
+-      LowerCost &me = *new (allocate_child())  LowerCost(0, stride, points, x, work_mem, K);
+-      is_continuation = true;
+-      return &me;
+-    }else {
+-      /* continuation */
+-      return NULL;
+-    }
+-  }
+-};
+-
+-
+-
+-
+-class CenterClose: public tbb::task {
+-  Points *points;
+-  double *work_mem;
+-  double *number_of_centers_to_close;
+-  double z;
+-  int pid, stride;
+-  int K;
+-
+-public:
+-  CenterClose(int id, int s, Points *p, double *mem, int k, double z_): 
+-    pid(id),stride(s),points(p),work_mem(mem),K(k), z(z_){}
+-
+-  task *execute() {
+-    double* gl_lower = &work_mem[(NUM_DIVISIONS)*stride];
+-    double *cost_of_opening_x;
+-    int local_number_of_centers_to_close = 0;
+-    long bsize = points->num/((NUM_DIVISIONS)); //
+-    long k1 = bsize * pid;
+-    long k2 = k1 + bsize;
+-
+-    if( pid == (NUM_DIVISIONS)-1 ) 
+-      k2 = points->num;
+-
+-    /*fprintf(stderr,"\t[CenterClose]: pid=%d stride=%d from %d to %d\n",
+-      pid, stride, k1, k2); */
+-
+-    number_of_centers_to_close = &work_mem[pid*stride + K];
+-    cost_of_opening_x = &work_mem[pid*stride + K+1];
+-    
+-      for ( int i = k1; i < k2; i++ ) {
+-	if( is_center[i] ) {
+-	  double low = z;
+-	  //aggregate from all threads
+-	  for( int p = 0; p < (NUM_DIVISIONS); p++ ) {
+-	    low += work_mem[center_table[i]+p*stride];
+-	  }
+-	  gl_lower[center_table[i]] = low;
+-	  if ( low > 0 ) {
+-	    // i is a median, and
+-	    // if we were to open x (which we still may not) we'd close i
+-	    
+-	    // note, we'll ignore the following quantity unless we do open x
+-	    ++local_number_of_centers_to_close;  
+-	    *cost_of_opening_x -= low;
+-	  }
+-	}
+-      }
+-      *number_of_centers_to_close = (double)local_number_of_centers_to_close;
+-      return NULL;
+-  }
+-
+-};
+-
+-
+-class CenterCloseTask: public tbb::task {
+-  bool is_continuation;
+-  Points *points;
+-  double *work_mem;
+-  int stride;
+-  double z;
+-  int K;
+-public:
+-  CenterCloseTask(int s, Points *p, double *mem, int k, double z_): 
+-    stride(s),points(p),work_mem(mem),K(k), z(z_), is_continuation(false){}
+-
+-  task *execute() {
+-    tbb::task_list list;
+-    int p;
+-    if(!is_continuation) {
+-      recycle_as_continuation();
+-      set_ref_count(NUM_DIVISIONS);
+-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
+-	list.push_back( *new( allocate_child() )  CenterClose(p, stride, points, work_mem, K, z));
+-      spawn(list);
+-      CenterClose &me = *new (allocate_child())  CenterClose(0, stride, points, work_mem, K, z);
+-      is_continuation = true;
+-      return &me;
+-    }else {
+-      /* coninuation */
+-
+-
+-      return NULL;
+-    }
+-  }
+-};
+-
+-
+-
+-class SaveMoney: public tbb::task{
+-  Points *points;
+-  double *work_mem;
+-  long x;
+-  int pid, stride;
+-public:
+-  SaveMoney(int id, int s, Points *p, long x_, double *mem): 
+-    pid(id), stride(s), points(p), x(x_), work_mem(mem){}
+-  task *execute() {
+-    double* gl_lower = &work_mem[(NUM_DIVISIONS)*stride];
+-    long bsize = points->num/((NUM_DIVISIONS));//points->num/1;//((NUM_DIVISIONS));
+-    long k1 = bsize * pid;
+-    long k2 = k1 + bsize;
+-    int i;
+-    
+-    if( pid == (NUM_DIVISIONS)-1 ) 
+-      k2 = points->num;
+-
+-    /*fprintf(stderr,"\t[SaveMoney]: pid=%d stride=%d from %d to %d\n",
+-      pid, stride, k1, k2);   */
+-    
+-
+-    //  we'd save money by opening x; we'll do it
+-    for ( int i = k1; i < k2; i++ ) {
+-      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;
+-      if ( switch_membership[i] || close_center ) {
+-	// Either i's median (which may be i itself) is closing,
+-	// or i is closer to x than to its current median
+-	points->p[i].cost = points->p[i].weight *
+-	  dist(points->p[i], points->p[x], points->dim);
+-	points->p[i].assign = x;
+-	//fprintf(stderr,"\t[SaveMoney] %d: cost %lf, x=%d\n",i,points->p[i].cost, x);
+-      }
+-    }
+-    for( int i = k1; i < k2; i++ ) {
+-      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {
+-	is_center[i] = false;
+-      }
+-    }
+-    if( x >= k1 && x < k2 ) {
+-      //fprintf(stderr,"\t-->is_center[%d]=true!\n",x);
+-      is_center[x] = true;
+-    }
+-
+-
+-    return NULL;
+-  }
+-};
+-
+-
+-class SaveMoneyTask: public tbb::task {
+-  bool is_continuation;
+-  Points *points;
+-  long x;
+-  double* work_mem;
+-  int stride;
+-
+-public:
+-  SaveMoneyTask(int s, Points *p, long x_, double *mem): 
+-    stride(s), points(p), x(x_), work_mem(mem) ,is_continuation(false){}
+-
+-
+-  task *execute() {
+-    tbb::task_list list;
+-    int p;
+-    if(!is_continuation) {
+-      recycle_as_continuation();
+-      set_ref_count(NUM_DIVISIONS);
+-      for(p = 1; p < (NUM_DIVISIONS); p++ ) 
+-	list.push_back( *new( allocate_child() )  SaveMoney(p, stride, points, x, work_mem));
+-      spawn(list);
+-      SaveMoney &me = *new (allocate_child())  SaveMoney(0, stride, points, x, work_mem);
+-      is_continuation = true;
+-      return &me;
+-    }else {
+-      /* coninuation */
+-
+-
+-      return NULL;
+-    }
+-  }
+-};
+-
+-#endif //TBB_VERSION
+-/********************************************/
+-
+-
+-
+ int isIdentical(float *i, float *j, int D)
+ // tells whether two points of D dimensions are identical
+ {
+-  int a = 0;
+-  int equal = 1;
++    int a = 0;
++    int equal = 1;
+ 
+-  while (equal && a < D) {
+-    if (i[a] != j[a]) equal = 0;
+-    else a++;
+-  }
+-  if (equal) return 1;
+-  else return 0;
++    while (equal && a < D) {
++        if (i[a] != j[a]) equal = 0;
++        else a++;
++    }
++    if (equal) return 1;
++    else return 0;
+ 
+ }
+ 
+ /* comparator for floating point numbers */
+ static int floatcomp(const void *i, const void *j)
+ {
+-  float a, b;
+-  a = *(float *)(i);
+-  b = *(float *)(j);
+-  if (a > b) return (1);
+-  if (a < b) return (-1);
+-  return(0);
++    float a, b;
++    a = *(float *)(i);
++    b = *(float *)(j);
++    if (a > b) return (1);
++    if (a < b) return (-1);
++    return(0);
+ }
+ 
+ /* shuffle points into random order */
+ void shuffle(Points *points)
+ {
+-  long i, j;
+-  Point temp;
+-  for (i=0;i<points->num-1;i++) {
+-    j=(lrand48()%(points->num - i)) + i;
+-    temp = points->p[i];
+-    points->p[i] = points->p[j];
+-    points->p[j] = temp;
+-  }
++    long i, j;
++    Point temp;
++    for (i=0;i<points->num-1;i++) {
++        j=(lrand48()%(points->num - i)) + i;
++        temp = points->p[i];
++        points->p[i] = points->p[j];
++        points->p[j] = temp;
++    }
+ }
+ 
+ /* shuffle an array of integers */
+ void intshuffle(int *intarray, int length)
+ {
+-  long i, j;
+-  int temp;
+-  for (i=0;i<length;i++) {
+-    j=(lrand48()%(length - i))+i;
+-    temp = intarray[i];
+-    intarray[i]=intarray[j];
+-    intarray[j]=temp;
+-  }
++    long i, j;
++    int temp;
++    for (i=0;i<length;i++) {
++        j=(lrand48()%(length - i))+i;
++        temp = intarray[i];
++        intarray[i]=intarray[j];
++        intarray[j]=temp;
++    }
+ }
+ 
++// Define access function to use as an alternative way to access array
++#define SK_P(x) (sk_block_a+x)
++
+ /* compute Euclidean distance squared between two points */
++// SK: this does not seem to be called with Points from center as arguments, all of them are Points
+ float dist(Point p1, Point p2, int dim)
+ {
+-  int i;
+-  float result=0.0;
+-  for (i=0;i<dim;i++)
+-    result += (p1.coord[i] - p2.coord[i])*(p1.coord[i] - p2.coord[i]);
+-  return(result);
+-}
+-
+-#ifdef TBB_VERSION
+-/* run speedy on the points, return total cost of solution */
+-float pspeedy(Points *points, float z, long *kcenter)
+-{
+-  static double totalcost;
+-  static bool open = false;
+-  static double* costs; //cost for each thread. 
+-  static int i;
+-
+-
+-  /* create center at first point, send it to itself */
+-  {
+-    int grain_size = points->num / ((NUM_DIVISIONS));
+-    CenterCreate c(points);
+-    tbb::parallel_for(tbb::blocked_range<int>(0,points->num, grain_size),c);
+-  }
+-    
+-  *kcenter = 1;
+-
+-
+-  {
+-    int grain_size = points->num / ((NUM_DIVISIONS));
+-    double acc_cost = 0.0;
+-    CenterOpen c(points);
+-    for(i = 1; i < points->num; i++ )  {
+-      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);
+-      if( to_open )  {
+-	(*kcenter)++;
+-	c.i = i;
+-	//fprintf(stderr,"** New center for i=%d\n",i);
+-	tbb::parallel_reduce(tbb::blocked_range<int>(0,points->num,grain_size),c);
+-      }
+-    }
+-
+-    c.type = 1; /* Once last time for actual reduction */
+-    tbb::parallel_reduce(tbb::blocked_range<int>(0,points->num,grain_size),c);
+-
+-
+-    totalcost =z*(*kcenter);
+-    totalcost += c.getTotalCost();
+-  }
+-  return(totalcost);
++    int i;
++    float result=0.0;
++    for (i=0;i<dim;i++)
++        result += (SK_P(p1.coord_idx)[i] - SK_P(p2.coord_idx)[i])*
++            (SK_P(p1.coord_idx)[i] - SK_P(p2.coord_idx)[i]);
++    return(result);
+ }
+ 
+-#else //!TBB_VERSION
+-
+ float pspeedy(Points *points, float z, long *kcenter, int pid, pthread_barrier_t* barrier)
+ {
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  //my block
+-  long bsize = points->num/nproc;
+-  long k1 = bsize * pid;
+-  long k2 = k1 + bsize;
+-  if( pid == nproc-1 ) k2 = points->num;
++    //my block
++    long bsize = points->num/nproc;
++    long k1 = bsize * pid;
++    long k2 = k1 + bsize;
++    if( pid == nproc-1 ) k2 = points->num;
+ 
+-  static double totalcost;
++    static double totalcost;
+ 
+-  static bool open = false;
+-  static double* costs; //cost for each thread. 
+-  static int i;
++    static bool open = false;
++    static double* costs; //cost for each thread.
++    static int i;
+ 
+ #ifdef ENABLE_THREADS
+-  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+-  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
++    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
++    static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
+ #endif
+ 
+-  /* create center at first point, send it to itself */
+-  for( int k = k1; k < k2; k++ )    {
+-    float distance = dist(points->p[k],points->p[0],points->dim);
+-    points->p[k].cost = distance * points->p[k].weight;
+-    points->p[k].assign=0;
+-  }
++    /* create center at first point, send it to itself */
++    for( int k = k1; k < k2; k++ )    {
++        float distance = dist(points->p[k],points->p[0],points->dim);
++        points->p[k].cost = distance * points->p[k].weight;
++        points->p[k].assign=0;
++    }
+ 
+-  if( pid==0 )   {
+-    *kcenter = 1;
+-    costs = (double*)malloc(sizeof(double)*nproc);
+-  }
++    if( pid==0 )   {
++        *kcenter = 1;
++        costs = (double*)malloc(sizeof(double)*nproc);
++    }
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-    
+-  if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.
+-    while(1) {
++
++    if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.
++        while(1) {
+ #ifdef ENABLE_THREADS
+-      pthread_mutex_lock(&mutex);
+-      while(!open) pthread_cond_wait(&cond,&mutex);
+-      pthread_mutex_unlock(&mutex);
++            pthread_mutex_lock(&mutex);
++            while(!open) pthread_cond_wait(&cond,&mutex);
++            pthread_mutex_unlock(&mutex);
+ #endif
+-      if( i >= points->num ) break;
+-      for( int k = k1; k < k2; k++ )
+-	{
+-	  float distance = dist(points->p[i],points->p[k],points->dim);
+-	  if( distance*points->p[k].weight < points->p[k].cost )
+-	    {
+-	      points->p[k].cost = distance * points->p[k].weight;
+-	      points->p[k].assign=i;
+-	    }
+-	}
++            if( i >= points->num ) break;
++            for( int k = k1; k < k2; k++ )
++                {
++                    float distance = dist(points->p[i],points->p[k],points->dim);
++                    if( distance*points->p[k].weight < points->p[k].cost )
++                        {
++                            points->p[k].cost = distance * points->p[k].weight;
++                            points->p[k].assign=i;
++                        }
++                }
+ #ifdef ENABLE_THREADS
+-      pthread_barrier_wait(barrier);
+-      pthread_barrier_wait(barrier);
++            pthread_barrier_wait(barrier);
++            pthread_barrier_wait(barrier);
+ #endif
+-    } 
+-  }
+-  else  { // I am the master thread. I decide whether to open a center and notify others if so. 
+-    for(i = 1; i < points->num; i++ )  {
+-      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);
+-      if( to_open )  {
+-	(*kcenter)++;
++        }
++    }
++    else  { // I am the master thread. I decide whether to open a center and notify others if so.
++        for(i = 1; i < points->num; i++ )  {
++            bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);
++            if( to_open )  {
++                (*kcenter)++;
+ #ifdef ENABLE_THREADS
+-	pthread_mutex_lock(&mutex);
++                pthread_mutex_lock(&mutex);
+ #endif
+-	open = true;
++                open = true;
+ #ifdef ENABLE_THREADS
+-	pthread_mutex_unlock(&mutex);
+-	pthread_cond_broadcast(&cond);
++                pthread_mutex_unlock(&mutex);
++                pthread_cond_broadcast(&cond);
+ #endif
+-	for( int k = k1; k < k2; k++ )  {
+-	  float distance = dist(points->p[i],points->p[k],points->dim);
+-	  if( distance*points->p[k].weight < points->p[k].cost )  {
+-	    points->p[k].cost = distance * points->p[k].weight;
+-	    points->p[k].assign=i;
+-	  }
+-	}
++                for( int k = k1; k < k2; k++ )  {
++                    float distance = dist(points->p[i],points->p[k],points->dim);
++                    if( distance*points->p[k].weight < points->p[k].cost )  {
++                        points->p[k].cost = distance * points->p[k].weight;
++                        points->p[k].assign=i;
++                    }
++                }
+ #ifdef ENABLE_THREADS
+-	pthread_barrier_wait(barrier);
++                pthread_barrier_wait(barrier);
+ #endif
+-	open = false;
++                open = false;
+ #ifdef ENABLE_THREADS
+-	pthread_barrier_wait(barrier);
++                pthread_barrier_wait(barrier);
+ #endif
+-      }
+-    }
++            }
++        }
+ #ifdef ENABLE_THREADS
+-    pthread_mutex_lock(&mutex);
++        pthread_mutex_lock(&mutex);
+ #endif
+-    open = true;
++        open = true;
+ #ifdef ENABLE_THREADS
+-    pthread_mutex_unlock(&mutex);
+-    pthread_cond_broadcast(&cond);
++        pthread_mutex_unlock(&mutex);
++        pthread_cond_broadcast(&cond);
+ #endif
+-  }
++    }
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  open = false;
+-  double mytotal = 0;
+-  for( int k = k1; k < k2; k++ )  {
+-    mytotal += points->p[k].cost;
+-  }
+-  costs[pid] = mytotal;
++    open = false;
++    double mytotal = 0;
++    for( int k = k1; k < k2; k++ )  {
++        mytotal += points->p[k].cost;
++    }
++    costs[pid] = mytotal;
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  // aggregate costs from each thread
+-  if( pid == 0 )
+-    {
+-      totalcost=z*(*kcenter);
+-      for( int i = 0; i < nproc; i++ )
+-	{
+-	  totalcost += costs[i];
+-	} 
+-      free(costs);
+-    }
++    // aggregate costs from each thread
++    if( pid == 0 )
++        {
++            totalcost=z*(*kcenter);
++            for( int i = 0; i < nproc; i++ )
++                {
++                    totalcost += costs[i];
++                }
++            free(costs);
++        }
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+ 
+-  return(totalcost);
++    return(totalcost);
+ }
+ 
+-#endif // TBB_VERSION
+-
+-
+ /* For a given point x, find the cost of the following operation:
+  * -- open a facility at x if there isn't already one there,
+  * -- for points y such that the assignment distance of y exceeds dist(y, x),
+  *    make y a member of x,
+- * -- for facilities y such that reassigning y and all its members to x 
++ * -- for facilities y such that reassigning y and all its members to x
+  *    would save cost, realize this closing and reassignment.
+- * 
++ *
+  * If the cost of this operation is negative (i.e., if this entire operation
+  * saves cost), perform this operation and return the amount of cost saved;
+  * otherwise, do nothing.
+  */
+ 
+ /* numcenters will be updated to reflect the new number of centers */
+-/* z is the facility cost, x is the number of this point in the array 
++/* z is the facility cost, x is the number of this point in the array
+    points */
+-
+-
+-#ifdef TBB_VERSION
+-double pgain(long x, Points *points, double z, long int *numcenters)
+-{
+-  int i;
+-  int number_of_centers_to_close = 0;
+-
+-  static double *work_mem;
+-  static double gl_cost_of_opening_x;
+-  static int gl_number_of_centers_to_close;
+-
+-  //each thread takes a block of working_mem.
+-  int stride = *numcenters+2;
+-
+-  //make stride a multiple of CACHE_LINE
+-  int cl = CACHE_LINE/sizeof(double);
+-  if( stride % cl != 0 ) { 
+-    stride = cl * ( stride / cl + 1);
+-  }
+-  int K = stride -2 ; // K==*numcenters
+-  
+-  //my own cost of opening x
+-  double cost_of_opening_x = 0;
+-
+-  work_mem = (double*) calloc(stride*((NUM_DIVISIONS)+1),sizeof(double));
+-  
+-  gl_cost_of_opening_x = 0;
+-  gl_number_of_centers_to_close = 0;
+-
+-
+-  /*For each center, we have a *lower* field that indicates 
+-    how much we will save by closing the center. 
+-    Each thread has its own copy of the *lower* fields as an array.
+-    We first build a table to index the positions of the *lower* fields. 
+-  */
+-
+-  /*****  loopA() *****/
+-  {
+-    CenterTableCountTask &t = *new ( tbb::task::allocate_root() ) CenterTableCountTask(stride, points, work_mem);
+-    tbb::task::spawn_root_and_wait(t);
+-  }
+-
+-  
+-  {
+-    FixCenterTask &t = *new ( tbb::task::allocate_root() ) FixCenterTask(stride, points, work_mem);
+-    tbb::task::spawn_root_and_wait(t);
+-  }    
+-
+-  /***************/
+-
+-  //now we finish building the table. clear the working memory.
+-  memset(switch_membership, 0, points->num*sizeof(bool));
+-  memset(work_mem, 0, (NUM_DIVISIONS+1)*stride*sizeof(double));
+-
+-  /* loopB */
+-  {
+-    LowerCostTask &t = *new ( tbb::task::allocate_root() )  LowerCostTask(stride, points, x, work_mem, K);
+-    tbb::task::spawn_root_and_wait(t);
+-  }    
+-
+-  /* LoopC */
+-  {
+-    CenterCloseTask &t = *new ( tbb::task::allocate_root() )  CenterCloseTask(stride, points, work_mem, K, z);
+-    tbb::task::spawn_root_and_wait(t);
+-  }    
+-
+-
+-  gl_cost_of_opening_x = z;
+-  //aggregate
+-  for( int p = 0; p < (NUM_DIVISIONS); p++ ) {
+-    gl_number_of_centers_to_close += (int)work_mem[p*stride + K];
+-    gl_cost_of_opening_x += work_mem[p*stride+K+1];
+-  }
+-
+-  /*fprintf(stderr,"\tgl_number_of_centers_to_close = %d\n",gl_number_of_centers_to_close);
+-    fprintf(stderr,"\tgl_cost_of_opening_x = %lf\n",gl_cost_of_opening_x); */
+-
+-
+-  // Now, check whether opening x would save cost; if so, do it, and
+-  // otherwise do nothing
+-
+-  if ( gl_cost_of_opening_x < 0 ) {
+-
+-    /* loopD */
+-    SaveMoneyTask &t = *new ( tbb::task::allocate_root() )  SaveMoneyTask(stride, points, x, work_mem);
+-    tbb::task::spawn_root_and_wait(t);
+-
+-
+-    *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;    
+-  }
+-  else {
+-    gl_cost_of_opening_x = 0;  // the value we'll return
+-  }
+-
+-  free(work_mem);
+-
+-  return -gl_cost_of_opening_x;
+-}
+-
+-#else //!TBB_VERSION
+-
+-
+ double pgain(long x, Points *points, double z, long int *numcenters, int pid, pthread_barrier_t* barrier)
+ {
+-  //  printf("pgain pthread %d begin\n",pid);
++    //  printf("pgain pthread %d begin\n",pid);
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+ 
+-  //my block
+-  long bsize = points->num/nproc;
+-  long k1 = bsize * pid;
+-  long k2 = k1 + bsize;
+-  if( pid == nproc-1 ) k2 = points->num;
+-
+-  int i;
+-  int number_of_centers_to_close = 0;
+-
+-  static double *work_mem;
+-  static double gl_cost_of_opening_x;
+-  static int gl_number_of_centers_to_close;
++    //my block
++    long bsize = points->num/nproc;
++    long k1 = bsize * pid;
++    long k2 = k1 + bsize;
++    if( pid == nproc-1 ) k2 = points->num;
+ 
+-  //each thread takes a block of working_mem.
+-  int stride = *numcenters+2;
+-  //make stride a multiple of CACHE_LINE
+-  int cl = CACHE_LINE/sizeof(double);
+-  if( stride % cl != 0 ) { 
+-    stride = cl * ( stride / cl + 1);
+-  }
+-  int K = stride -2 ; // K==*numcenters
+-  
+-  //my own cost of opening x
+-  double cost_of_opening_x = 0;
++    int i;
++    int number_of_centers_to_close = 0;
+ 
+-  if( pid==0 )    { 
+-    work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));
+-    gl_cost_of_opening_x = 0;
+-    gl_number_of_centers_to_close = 0;
+-  }
++    static double *work_mem;
++    static double gl_cost_of_opening_x;
++    static int gl_number_of_centers_to_close;
++
++    //each thread takes a block of working_mem.
++    int stride = *numcenters+2;
++    //make stride a multiple of CACHE_LINE
++    int cl = CACHE_LINE/sizeof(double);
++    if( stride % cl != 0 ) {
++        stride = cl * ( stride / cl + 1);
++    }
++    int K = stride -2 ; // K==*numcenters
++
++    //my own cost of opening x
++    double cost_of_opening_x = 0;
++
++    if( pid==0 )    {
++        work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));
++        gl_cost_of_opening_x = 0;
++        gl_number_of_centers_to_close = 0;
++    }
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  /*For each center, we have a *lower* field that indicates 
+-    how much we will save by closing the center. 
+-    Each thread has its own copy of the *lower* fields as an array.
+-    We first build a table to index the positions of the *lower* fields. 
+-  */
++    /*For each center, we have a *lower* field that indicates
++      how much we will save by closing the center.
++      Each thread has its own copy of the *lower* fields as an array.
++      We first build a table to index the positions of the *lower* fields.
++    */
+ 
+-  int count = 0;
+-  for( int i = k1; i < k2; i++ ) {
+-    if( is_center[i] ) {
+-      center_table[i] = count++;
++    int count = 0;
++    for( int i = k1; i < k2; i++ ) {
++        if( is_center[i] ) {
++            center_table[i] = count++;
++        }
+     }
+-  }
+-  work_mem[pid*stride] = count;
++    work_mem[pid*stride] = count;
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+ 
+-  if( pid == 0 ) {
+-    int accum = 0;
+-    for( int p = 0; p < nproc; p++ ) {
+-      int tmp = (int)work_mem[p*stride];
+-      work_mem[p*stride] = accum;
+-      accum += tmp;
++    if( pid == 0 ) {
++        int accum = 0;
++        for( int p = 0; p < nproc; p++ ) {
++            int tmp = (int)work_mem[p*stride];
++            work_mem[p*stride] = accum;
++            accum += tmp;
++        }
+     }
+-  }
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+ 
+-  for( int i = k1; i < k2; i++ ) {
+-    if( is_center[i] ) {
+-      center_table[i] += (int)work_mem[pid*stride];
++    for( int i = k1; i < k2; i++ ) {
++        if( is_center[i] ) {
++            center_table[i] += (int)work_mem[pid*stride];
++        }
+     }
+-  }
+ 
+-  //now we finish building the table. clear the working memory.
+-  memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));
+-  memset(work_mem+pid*stride, 0, stride*sizeof(double));
+-  if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));
++    //now we finish building the table. clear the working memory.
++    memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));
++    memset(work_mem+pid*stride, 0, stride*sizeof(double));
++    if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  
+-  //my *lower* fields
+-  double* lower = &work_mem[pid*stride];
+-  //global *lower* fields
+-  double* gl_lower = &work_mem[nproc*stride];
+-
+-  for ( i = k1; i < k2; i++ ) {
+-    float x_cost = dist(points->p[i], points->p[x], points->dim) 
+-      * points->p[i].weight;
+-    float current_cost = points->p[i].cost;
+-
+-    if ( x_cost < current_cost ) {
+ 
+-      // point i would save cost just by switching to x
+-      // (note that i cannot be a median, 
+-      // or else dist(p[i], p[x]) would be 0)
+-      
+-      switch_membership[i] = 1;
+-      cost_of_opening_x += x_cost - current_cost;
+-
+-    } else {
+-
+-      // cost of assigning i to x is at least current assignment cost of i
++    //my *lower* fields
++    double* lower = &work_mem[pid*stride];
++    //global *lower* fields
++    double* gl_lower = &work_mem[nproc*stride];
+ 
+-      // consider the savings that i's **current** median would realize
+-      // if we reassigned that median and all its members to x;
+-      // note we've already accounted for the fact that the median
+-      // would save z by closing; now we have to subtract from the savings
+-      // the extra cost of reassigning that median and its members 
+-      int assign = points->p[i].assign;
+-      lower[center_table[assign]] += current_cost - x_cost;
++    for ( i = k1; i < k2; i++ ) {
++        float x_cost = dist(points->p[i], points->p[x], points->dim)
++            * points->p[i].weight;
++        float current_cost = points->p[i].cost;
++
++        if ( x_cost < current_cost ) {
++
++            // point i would save cost just by switching to x
++            // (note that i cannot be a median,
++            // or else dist(p[i], p[x]) would be 0)
++
++            switch_membership[i] = 1;
++            cost_of_opening_x += x_cost - current_cost;
++
++        } else {
++
++            // cost of assigning i to x is at least current assignment cost of i
++
++            // consider the savings that i's **current** median would realize
++            // if we reassigned that median and all its members to x;
++            // note we've already accounted for the fact that the median
++            // would save z by closing; now we have to subtract from the savings
++            // the extra cost of reassigning that median and its members
++            int assign = points->p[i].assign;
++            lower[center_table[assign]] += current_cost - x_cost;
++        }
+     }
+-  }
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+ 
+-  // at this time, we can calculate the cost of opening a center
+-  // at x; if it is negative, we'll go through with opening it
+-
+-  for ( int i = k1; i < k2; i++ ) {
+-    if( is_center[i] ) {
+-      double low = z;
+-      //aggregate from all threads
+-      for( int p = 0; p < nproc; p++ ) {
+-	low += work_mem[center_table[i]+p*stride];
+-      }
+-      gl_lower[center_table[i]] = low;
+-      if ( low > 0 ) {
+-	// i is a median, and
+-	// if we were to open x (which we still may not) we'd close i
++    // at this time, we can calculate the cost of opening a center
++    // at x; if it is negative, we'll go through with opening it
+ 
+-	// note, we'll ignore the following quantity unless we do open x
+-	++number_of_centers_to_close;  
+-	cost_of_opening_x -= low;
+-      }
+-    }
+-  }
+-  //use the rest of working memory to store the following
+-  work_mem[pid*stride + K] = number_of_centers_to_close;
+-  work_mem[pid*stride + K+1] = cost_of_opening_x;
++    for ( int i = k1; i < k2; i++ ) {
++        if( is_center[i] ) {
++            double low = z;
++            //aggregate from all threads
++            for( int p = 0; p < nproc; p++ ) {
++                low += work_mem[center_table[i]+p*stride];
++            }
++            gl_lower[center_table[i]] = low;
++            if ( low > 0 ) {
++                // i is a median, and
++                // if we were to open x (which we still may not) we'd close i
++
++                // note, we'll ignore the following quantity unless we do open x
++                ++number_of_centers_to_close;
++                cost_of_opening_x -= low;
++            }
++        }
++    }
++    //use the rest of working memory to store the following
++    work_mem[pid*stride + K] = number_of_centers_to_close;
++    work_mem[pid*stride + K+1] = cost_of_opening_x;
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  //  printf("thread %d cost complete\n",pid); 
++    //  printf("thread %d cost complete\n",pid);
+ 
+-  if( pid==0 ) {
+-    gl_cost_of_opening_x = z;
+-    //aggregate
+-    for( int p = 0; p < nproc; p++ ) {
+-      gl_number_of_centers_to_close += (int)work_mem[p*stride + K];
+-      gl_cost_of_opening_x += work_mem[p*stride+K+1];
++    if( pid==0 ) {
++        gl_cost_of_opening_x = z;
++        //aggregate
++        for( int p = 0; p < nproc; p++ ) {
++            gl_number_of_centers_to_close += (int)work_mem[p*stride + K];
++            gl_cost_of_opening_x += work_mem[p*stride+K+1];
++        }
+     }
+-  }
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
++    pthread_barrier_wait(barrier);
+ #endif
+-  // Now, check whether opening x would save cost; if so, do it, and
+-  // otherwise do nothing
++    // Now, check whether opening x would save cost; if so, do it, and
++    // otherwise do nothing
+ 
+-  if ( gl_cost_of_opening_x < 0 ) {
+-    //  we'd save money by opening x; we'll do it
+-    for ( int i = k1; i < k2; i++ ) {
+-      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;
+-      if ( switch_membership[i] || close_center ) {
+-	// Either i's median (which may be i itself) is closing,
+-	// or i is closer to x than to its current median
+-	points->p[i].cost = points->p[i].weight *
+-	  dist(points->p[i], points->p[x], points->dim);
+-	points->p[i].assign = x;
+-      }
+-    }
+-    for( int i = k1; i < k2; i++ ) {
+-      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {
+-	is_center[i] = false;
+-      }
++    if ( gl_cost_of_opening_x < 0 ) {
++        //  we'd save money by opening x; we'll do it
++        for ( int i = k1; i < k2; i++ ) {
++            bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;
++            if ( switch_membership[i] || close_center ) {
++                // Either i's median (which may be i itself) is closing,
++                // or i is closer to x than to its current median
++                points->p[i].cost = points->p[i].weight *
++                    dist(points->p[i], points->p[x], points->dim);
++                points->p[i].assign = x;
++            }
++        }
++        for( int i = k1; i < k2; i++ ) {
++            if( is_center[i] && gl_lower[center_table[i]] > 0 ) {
++                is_center[i] = false;
++            }
++        }
++        if( x >= k1 && x < k2 ) {
++            is_center[x] = true;
++        }
++
++        if( pid==0 ) {
++            *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;
++        }
+     }
+-    if( x >= k1 && x < k2 ) {
+-      is_center[x] = true;
++    else {
++        if( pid==0 )
++            gl_cost_of_opening_x = 0;  // the value we'll return
+     }
+-
+-    if( pid==0 ) {
+-      *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;
++#ifdef ENABLE_THREADS
++    pthread_barrier_wait(barrier);
++#endif
++    if( pid == 0 ) {
++        free(work_mem);
++        //    free(is_center);
++        //    free(switch_membership);
++        //    free(proc_cost_of_opening_x);
++        //    free(proc_number_of_centers_to_close);
+     }
+-  }
+-  else {
+-    if( pid==0 )
+-      gl_cost_of_opening_x = 0;  // the value we'll return
+-  }
+-#ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
+-#endif
+-  if( pid == 0 ) {
+-    free(work_mem);
+-    //    free(is_center);
+-    //    free(switch_membership);
+-    //    free(proc_cost_of_opening_x);
+-    //    free(proc_number_of_centers_to_close);
+-  }
+ 
+-  return -gl_cost_of_opening_x;
++    return -gl_cost_of_opening_x;
+ }
+ 
+-#endif // TBB_VERSION
+-
+-
+ 
+ /* facility location on the points using local search */
+ /* z is the facility cost, returns the total cost and # of centers */
+@@ -1170,571 +548,418 @@ double pgain(long x, Points *points, dou
+ /* cost should represent this solution's cost */
+ /* halt if there is < e improvement after iter calls to gain */
+ /* feasible is an array of numfeasible points which may be centers */
+-
+-#ifdef TBB_VERSION
+ float pFL(Points *points, int *feasible, int numfeasible,
+-	  double z, long *k, double cost, long iter, double e)
+-{
+-
+-  long i;
+-  long x;
+-  double change;
+-  long numberOfPoints;
+-
+-  change = cost;
+-  /* continue until we run iter iterations without improvement */
+-  /* stop instead if improvement is less than e */
+-  while (change/cost > 1.0*e) {
+-    change = 0.0;
+-    numberOfPoints = points->num;
+-    /* randomize order in which centers are considered */    
+-    intshuffle(feasible, numfeasible);
+-
+-    for (i=0;i<iter;i++) {
+-      x = i%numfeasible;
+-      //fprintf(stderr,"Iteration %d z=%lf, change=%lf\n",i,z,change);
+-      change += pgain(feasible[x], points, z , k);
+-      //fprintf(stderr,"*** change: %lf, z=%lf\n",change,z);
+-    }
+-    cost -= change;
+-  }
+-
+-  return(cost);
+-}
+-
+-
+-#else //!TBB_VERSION
+- float pFL(Points *points, int *feasible, int numfeasible,
+-	  float z, long *k, double cost, long iter, float e, 
+-	  int pid, pthread_barrier_t* barrier)
++          float z, long *k, double cost, long iter, float e,
++          int pid, pthread_barrier_t* barrier)
+ {
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
+-#endif
+-  long i;
+-  long x;
+-  double change;
+-  long numberOfPoints;
+-
+-  change = cost;
+-  /* continue until we run iter iterations without improvement */
+-  /* stop instead if improvement is less than e */
+-  while (change/cost > 1.0*e) {
+-    change = 0.0;
+-    numberOfPoints = points->num;
+-    /* randomize order in which centers are considered */
+-
+-    if( pid == 0 ) {
+-      intshuffle(feasible, numfeasible);
+-    }
+-#ifdef ENABLE_THREADS
+     pthread_barrier_wait(barrier);
+ #endif
+-    for (i=0;i<iter;i++) {
+-      x = i%numfeasible;
+-      change += pgain(feasible[x], points, z, k, pid, barrier);
+-    }
+-    cost -= change;
++    long i;
++    long x;
++    double change;
++    long numberOfPoints;
++
++    change = cost;
++    /* continue until we run iter iterations without improvement */
++    /* stop instead if improvement is less than e */
++    while (change/cost > 1.0*e) {
++        change = 0.0;
++        numberOfPoints = points->num;
++        /* randomize order in which centers are considered */
++
++        if( pid == 0 ) {
++            intshuffle(feasible, numfeasible);
++        }
++#ifdef ENABLE_THREADS
++        pthread_barrier_wait(barrier);
++#endif
++        for (i=0;i<iter;i++) {
++            x = i%numfeasible;
++            change += pgain(feasible[x], points, z, k, pid, barrier);
++        }
++        cost -= change;
+ #ifdef ENABLE_THREADS
+-    pthread_barrier_wait(barrier);
++        pthread_barrier_wait(barrier);
+ #endif
+-  }
+-  return(cost);
++    }
++    return(cost);
+ }
+ 
+-#endif // TBB_VERSION
+-
+-
+-
+-#ifdef TBB_VERSION
+-int selectfeasible_fast(Points *points, int **feasible, int kmin)
+-#else
+ int selectfeasible_fast(Points *points, int **feasible, int kmin, int pid, pthread_barrier_t* barrier)
+-#endif
+ {
+-  int numfeasible = points->num;
+-  if (numfeasible > (ITER*kmin*log((double)kmin)))
+-    numfeasible = (int)(ITER*kmin*log((double)kmin));
+-  *feasible = (int *)malloc(numfeasible*sizeof(int));
+-  
+-  float* accumweight;
+-  float totalweight;
+-
+-  /* 
+-     Calcuate my block. 
+-     For now this routine does not seem to be the bottleneck, so it is not parallelized. 
+-     When necessary, this can be parallelized by setting k1 and k2 to 
+-     proper values and calling this routine from all threads ( it is called only
+-     by thread 0 for now ). 
+-     Note that when parallelized, the randomization might not be the same and it might
+-     not be difficult to measure the parallel speed-up for the whole program. 
+-   */
+-  //  long bsize = numfeasible;
+-  long k1 = 0;
+-  long k2 = numfeasible;
+-
+-  float w;
+-  int l,r,k;
+-
+-  /* not many points, all will be feasible */
+-  if (numfeasible == points->num) {
+-    for (int i=k1;i<k2;i++)
+-      (*feasible)[i] = i;
+-    return numfeasible;
+-  }
+-#ifdef TBB_VERSION
+-  accumweight= (float*)memoryFloat.allocate(sizeof(float)*points->num);
+-#else
+-  accumweight= (float*)malloc(sizeof(float)*points->num);
+-#endif
++    int numfeasible = points->num;
++    if (numfeasible > (ITER*kmin*log((double)kmin)))
++        numfeasible = (int)(ITER*kmin*log((double)kmin));
++    *feasible = (int *)malloc(numfeasible*sizeof(int));
++
++    float* accumweight;
++    float totalweight;
++
++    /*
++      Calcuate my block.
++      For now this routine does not seem to be the bottleneck, so it is not parallelized.
++      When necessary, this can be parallelized by setting k1 and k2 to
++      proper values and calling this routine from all threads ( it is called only
++      by thread 0 for now ).
++      Note that when parallelized, the randomization might not be the same and it might
++      not be difficult to measure the parallel speed-up for the whole program.
++    */
++    //  long bsize = numfeasible;
++    long k1 = 0;
++    long k2 = numfeasible;
+ 
+-  accumweight[0] = points->p[0].weight;
+-  totalweight=0;
+-  for( int i = 1; i < points->num; i++ ) {
+-    accumweight[i] = accumweight[i-1] + points->p[i].weight;
+-  }
+-  totalweight=accumweight[points->num-1];
+-
+-  for(int i=k1; i<k2; i++ ) {
+-    w = (lrand48()/(float)INT_MAX)*totalweight;
+-    //binary search
+-    l=0;
+-    r=points->num-1;
+-    if( accumweight[0] > w )  { 
+-      (*feasible)[i]=0; 
+-      continue;
+-    }
+-    while( l+1 < r ) {
+-      k = (l+r)/2;
+-      if( accumweight[k] > w ) {
+-	r = k;
+-      } 
+-      else {
+-	l=k;
+-      }
++    float w;
++    int l,r,k;
++
++    /* not many points, all will be feasible */
++    if (numfeasible == points->num) {
++        for (int i=k1;i<k2;i++)
++            (*feasible)[i] = i;
++        return numfeasible;
++    }
++    accumweight= (float*)malloc(sizeof(float)*points->num);
++
++    accumweight[0] = points->p[0].weight;
++    totalweight=0;
++    for( int i = 1; i < points->num; i++ ) {
++        accumweight[i] = accumweight[i-1] + points->p[i].weight;
++    }
++    totalweight=accumweight[points->num-1];
++
++    for(int i=k1; i<k2; i++ ) {
++        w = (lrand48()/(float)INT_MAX)*totalweight;
++        //binary search
++        l=0;
++        r=points->num-1;
++        if( accumweight[0] > w )  {
++            (*feasible)[i]=0;
++            continue;
++        }
++        while( l+1 < r ) {
++            k = (l+r)/2;
++            if( accumweight[k] > w ) {
++                r = k;
++            }
++            else {
++                l=k;
++            }
++        }
++        (*feasible)[i]=r;
+     }
+-    (*feasible)[i]=r;
+-  }
+ 
+-#ifdef TBB_VERSION
+-  memoryFloat.deallocate(accumweight, sizeof(float));
+-#else
+-  free(accumweight); 
+-#endif
++    free(accumweight);
+ 
+-  return numfeasible;
++    return numfeasible;
+ }
+ 
+-
+-
+-#ifdef TBB_VERSION
+ /* compute approximate kmedian on the points */
+ float pkmedian(Points *points, long kmin, long kmax, long* kfinal,
+-	       int pid, pthread_barrier_t* barrier )
++               int pid, pthread_barrier_t* barrier )
+ {
+-  int i;
+-  double cost;
+-  double lastcost;
+-  double hiz, loz, z;
+-
+-  static long k;
+-  static int *feasible;
+-  static int numfeasible;
+-  static double* hizs;
+-
+-
+-  //  hizs = (double*)calloc(nproc,sizeof(double));
+-  hiz = loz = 0.0;
+-  long numberOfPoints = points->num;
+-  long ptDimension = points->dim;
+-
+-  //my block
+-  long bsize = points->num/nproc;
+-  long k1 = bsize * pid;
+-  long k2 = k1 + bsize;
+-  if( pid == nproc-1 ) k2 = points->num;
+-
+-  
+-  //fprintf(stderr,"Starting Kmedian procedure\n");
+-  //fprintf(stderr,"%i points in %i dimensions\n", numberOfPoints, ptDimension);
+-
+-  int grain_size = points->num / ((NUM_DIVISIONS));
+-  if(grain_size==0)
+-    {
+-      
+-      for (long kk=0;kk < points->num; kk++ ) 
+-	{
+-	  hiz += dist(points->p[kk], points->p[0],
+-		      ptDimension)*points->p[kk].weight;
+-	}
+-      
+-    }
+-  else {
+-    HizReduction h(points);
+-    tbb::parallel_reduce(tbb::blocked_range<int>(0,points->num, grain_size), h);
+-    hiz = h.getHiz();
+-  }
+-
+-  loz=0.0; z = (hiz+loz)/2.0;
+-
+-  /* NEW: Check whether more centers than points! */
+-  if (points->num <= kmax) {
+-    /* just return all points as facilities */
+-      for (long kk=0;kk<points->num;kk++) 
+-	{
+-	  points->p[kk].assign = kk;
+-	  points->p[kk].cost = 0;
+-	}
+-    
+-    cost = 0;
+-    *kfinal = k;
+-
+-    return cost;
+-  }
+-
+-    shuffle(points);
+-    cost = pspeedy(points, z, &k);
+-
+-    i=0;
++    static int skpkmit = 0;
++    int i;
++    double cost;
++    double lastcost;
++    double hiz, loz, z;
++
++    static long k;
++    static int *feasible;
++    static int numfeasible;
++    static double* hizs;
++
++    if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));
++    hiz = loz = 0.0;
++    long numberOfPoints = points->num;
++    long ptDimension = points->dim;
+ 
+-  /* give speedy SP chances to get at least kmin/2 facilities */
+-  while ((k < kmin)&&(i<SP)) {
+-    cost = pspeedy(points, z, &k);
+-    i++;
+-  }
+-
+-  /* if still not enough facilities, assume z is too high */
+-  while (k < kmin) {
+-    if (i >= SP) 
+-      {hiz=z; z=(hiz+loz)/2.0; i=0;}
+-    
+-    shuffle(points);
+-    cost =  pspeedy(points, z, &k);
+-    i++;
+-  }
+-
+-  /* now we begin the binary search for real */
+-  /* must designate some points as feasible centers */
+-  /* this creates more consistancy between FL runs */
+-  /* helps to guarantee correct # of centers at the end */
+-
+-    numfeasible = selectfeasible_fast(points,&feasible,kmin);
+-    for( int i = 0; i< points->num; i++ ) {
+-      //fprintf(stderr,"\t-->is_center[%d]=true!\n",points->p[i].assign);
+-      is_center[points->p[i].assign]= true;
+-    }
+-
+-
+-  while(1) {
+-    /* first get a rough estimate on the FL solution */
+-    lastcost = cost;
+-    cost = pFL(points, feasible, numfeasible,
+-	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1);
+-
+-    /* if number of centers seems good, try a more accurate FL */
+-    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||
+-	((k <= kmax+2)&&(k >= kmin-2))) {
+-      
+-      /* may need to run a little longer here before halting without
+-	 improvement */
+-      cost = pFL(points, feasible, numfeasible,
+-		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001);
+-    }
+-
+-    if (k > kmax) {
+-      /* facilities too cheap */
+-      /* increase facility cost and up the cost accordingly */
+-      loz = z; z = (hiz+loz)/2.0;
+-      cost += (z-loz)*k;
+-    }
+-    if (k < kmin) {
+-      /* facilities too expensive */
+-      /* decrease facility cost and reduce the cost accordingly */
+-      hiz = z; z = (hiz+loz)/2.0;
+-      cost += (z-hiz)*k;
+-    }
+-
+-    /* if k is good, return the result */
+-    /* if we're stuck, just give up and return what we have */
+-    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )
+-      { 
+-	break;
+-      }
+-
+-  }
+-
+-  //  fprintf(stderr,"Cleaning up...\n");
+-  //clean up...
+-  free(feasible); 
+-  *kfinal = k;
++    //my block
++    long bsize = points->num/nproc;
++    // --------------------------------------------------
++    // select range of array this thread should work on
++    long k1 = bsize * pid;
++    long k2 = k1 + bsize;
++    // --------------------------------------------------
++    if( pid == nproc-1 ) k2 = points->num;
+ 
+-  return cost;
+-}
++#ifdef ENABLE_THREADS
++    pthread_barrier_wait(barrier);
++#endif
+ 
++    double myhiz = 0;
++    for (long kk=k1;kk < k2; kk++ ) {
++        // SK: Indexed access
++        myhiz += dist(points->p[kk], points->p[0],
++                      ptDimension)*points->p[kk].weight;
++    }
++    hizs[pid] = myhiz;
+ 
+-#else //!TBB_VERSION
++#ifdef ENABLE_THREADS
++    pthread_barrier_wait(barrier);
++#endif
+ 
+-/* compute approximate kmedian on the points */
+-float pkmedian(Points *points, long kmin, long kmax, long* kfinal,
+-	       int pid, pthread_barrier_t* barrier )
+-{
+-  int i;
+-  double cost;
+-  double lastcost;
+-  double hiz, loz, z;
+-
+-  static long k;
+-  static int *feasible;
+-  static int numfeasible;
+-  static double* hizs;
+-
+-  if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));
+-  hiz = loz = 0.0;
+-  long numberOfPoints = points->num;
+-  long ptDimension = points->dim;
+-
+-  //my block
+-  long bsize = points->num/nproc;
+-  long k1 = bsize * pid;
+-  long k2 = k1 + bsize;
+-  if( pid == nproc-1 ) k2 = points->num;
+-
+-#ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
+-#endif
+-
+-  double myhiz = 0;
+-  for (long kk=k1;kk < k2; kk++ ) {
+-    myhiz += dist(points->p[kk], points->p[0],
+-		      ptDimension)*points->p[kk].weight;
+-  }
+-  hizs[pid] = myhiz;
+-
+-#ifdef ENABLE_THREADS  
+-  pthread_barrier_wait(barrier);
+-#endif
+-
+-  for( int i = 0; i < nproc; i++ )   {
+-    hiz += hizs[i];
+-  }
+-
+-  loz=0.0; z = (hiz+loz)/2.0;
+-  /* NEW: Check whether more centers than points! */
+-  if (points->num <= kmax) {
+-    /* just return all points as facilities */
+-    for (long kk=k1;kk<k2;kk++) {
+-      points->p[kk].assign = kk;
+-      points->p[kk].cost = 0;
+-    }
+-    cost = 0;
+-    if( pid== 0 ) {
+-      free(hizs); 
+-      *kfinal = k;
++    for( int i = 0; i < nproc; i++ )   {
++        hiz += hizs[i];
+     }
+-    return cost;
+-  }
+-
+-  if( pid == 0 ) shuffle(points);
+-  cost = pspeedy(points, z, &k, pid, barrier);
+ 
+-  i=0;
+-  /* give speedy SP chances to get at least kmin/2 facilities */
+-  while ((k < kmin)&&(i<SP)) {
+-    cost = pspeedy(points, z, &k, pid, barrier);
+-    i++;
+-  }
++    loz=0.0; z = (hiz+loz)/2.0;
++    /* NEW: Check whether more centers than points! */
++    if (points->num <= kmax) {
++        /* just return all points as facilities */
++        for (long kk=k1;kk<k2;kk++) {
++            points->p[kk].assign = kk;
++            points->p[kk].cost = 0;
++        }
++        cost = 0;
++        if( pid== 0 ) {
++
++#ifdef SK_CRC_RUNTIME
++            // hizs
++            crc_t crc_h;
++            crc_h = crc_init();
++            crc_h = crc_update(crc_h, (unsigned char*) hizs, nproc*sizeof(double));
++            crc_h = crc_finalize(crc_h);
++            printf("Iteration %d: hizs=0x%lx\n", skpkmit++, crc_h);
++#endif /* SK_CRC_RUNTIME */
++
++            free(hizs);
++            *kfinal = k;
++        }
++        return cost;
++    }
+ 
+-  /* if still not enough facilities, assume z is too high */
+-  while (k < kmin) {
+-    if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}
+     if( pid == 0 ) shuffle(points);
+     cost = pspeedy(points, z, &k, pid, barrier);
+-    i++;
+-  }
+ 
+-  /* now we begin the binary search for real */
+-  /* must designate some points as feasible centers */
+-  /* this creates more consistancy between FL runs */
+-  /* helps to guarantee correct # of centers at the end */
+-  
+-  if( pid == 0 )
+-    {
+-      numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);
+-      for( int i = 0; i< points->num; i++ ) {
+-	is_center[points->p[i].assign]= true;
+-      }
+-    }
++    i=0;
++    /* give speedy SP chances to get at least kmin/2 facilities */
++    while ((k < kmin)&&(i<SP)) {
++        cost = pspeedy(points, z, &k, pid, barrier);
++        i++;
++    }
++
++    /* if still not enough facilities, assume z is too high */
++    while (k < kmin) {
++        if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}
++        if( pid == 0 ) shuffle(points);
++        cost = pspeedy(points, z, &k, pid, barrier);
++        i++;
++    }
++
++    /* now we begin the binary search for real */
++    /* must designate some points as feasible centers */
++    /* this creates more consistancy between FL runs */
++    /* helps to guarantee correct # of centers at the end */
++
++    if( pid == 0 )
++        {
++            numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);
++            for( int i = 0; i< points->num; i++ ) {
++                is_center[points->p[i].assign]= true;
++            }
++        }
+ 
+ #ifdef ENABLE_THREADS
+-  pthread_barrier_wait(barrier);
+-#endif
+-
+-  while(1) {
+-    /* first get a rough estimate on the FL solution */
+-    lastcost = cost;
+-    cost = pFL(points, feasible, numfeasible,
+-	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);
+-
+-    /* if number of centers seems good, try a more accurate FL */
+-    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||
+-	((k <= kmax+2)&&(k >= kmin-2))) {
+-
+-      /* may need to run a little longer here before halting without
+-	 improvement */
+-      cost = pFL(points, feasible, numfeasible,
+-		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);
+-    }
+-
+-    if (k > kmax) {
+-      /* facilities too cheap */
+-      /* increase facility cost and up the cost accordingly */
+-      loz = z; z = (hiz+loz)/2.0;
+-      cost += (z-loz)*k;
+-    }
+-    if (k < kmin) {
+-      /* facilities too expensive */
+-      /* decrease facility cost and reduce the cost accordingly */
+-      hiz = z; z = (hiz+loz)/2.0;
+-      cost += (z-hiz)*k;
+-    }
+-
+-    /* if k is good, return the result */
+-    /* if we're stuck, just give up and return what we have */
+-    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )
+-      { 
+-	break;
+-      }
+-#ifdef ENABLE_THREADS
+     pthread_barrier_wait(barrier);
+ #endif
+-  }
+-
+-  //clean up...
+-  if( pid==0 ) {
+-    free(feasible); 
+-    free(hizs);
+-    *kfinal = k;
+-  }
+ 
+-  return cost;
+-}
++    while(1) {
++        /* first get a rough estimate on the FL solution */
++        lastcost = cost;
++        cost = pFL(points, feasible, numfeasible,
++                   z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);
++
++        /* if number of centers seems good, try a more accurate FL */
++        if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||
++            ((k <= kmax+2)&&(k >= kmin-2))) {
++
++            /* may need to run a little longer here before halting without
++               improvement */
++            cost = pFL(points, feasible, numfeasible,
++                       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);
++        }
++
++        if (k > kmax) {
++            /* facilities too cheap */
++            /* increase facility cost and up the cost accordingly */
++            loz = z; z = (hiz+loz)/2.0;
++            cost += (z-loz)*k;
++        }
++        if (k < kmin) {
++            /* facilities too expensive */
++            /* decrease facility cost and reduce the cost accordingly */
++            hiz = z; z = (hiz+loz)/2.0;
++            cost += (z-hiz)*k;
++        }
++
++        /* if k is good, return the result */
++        /* if we're stuck, just give up and return what we have */
++        if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )
++            {
++                break;
++            }
++#ifdef ENABLE_THREADS
++        pthread_barrier_wait(barrier);
++#endif
++    }
+ 
+-#endif // TBB_VERSION
++    //clean up...
++    if( pid==0 ) {
+ 
++#ifdef SK_CRC_RUNTIME
++        // hizs
++        crc_t crc_h;
++        crc_h = crc_init();
++        crc_h = crc_update(crc_h, (unsigned char*) hizs, nproc*sizeof(double));
++        crc_h = crc_finalize(crc_h);
++        printf("Iteration %d: hizs=0x%lx\n", skpkmit++, crc_h);
++#endif /* SK_CRC_RUNTIME */
++
++        free(feasible);
++        free(hizs);
++        *kfinal = k;
++    }
+ 
++    return cost;
++}
+ 
+ 
+ /* compute the means for the k clusters */
++// This is execute for both: centers and coordinates
++// However, I though this would only be executed in non-parallel sections
+ int contcenters(Points *points)
+ {
+-  long i, ii;
+-  float relweight;
++    long i, ii;
++    float relweight;
+ 
+-  for (i=0;i<points->num;i++) {
+-    /* compute relative weight of this point to the cluster */
+-    if (points->p[i].assign != i) {
+-      relweight=points->p[points->p[i].assign].weight + points->p[i].weight;
+-      relweight = points->p[i].weight/relweight;
+-      for (ii=0;ii<points->dim;ii++) {
+-	points->p[points->p[i].assign].coord[ii]*=1.0-relweight;
+-	points->p[points->p[i].assign].coord[ii]+=
+-	  points->p[i].coord[ii]*relweight;
+-      }
+-      points->p[points->p[i].assign].weight += points->p[i].weight;
+-    }
+-  }
+-  
+-  return 0;
++    for (i=0;i<points->num;i++) {
++        /* compute relative weight of this point to the cluster */
++        if (points->p[i].assign != i) {
++            relweight=points->p[points->p[i].assign].weight + points->p[i].weight;
++            relweight = points->p[i].weight/relweight;
++            for (ii=0;ii<points->dim;ii++) {
++
++                // XXX Another write
++
++                long atmp = points->p[i].assign;
++                float ftmp = SK_P(points->p[atmp].coord_idx)[ii];
++
++                ftmp*=1.0-relweight;
++                ftmp+=
++                    SK_P(points->p[i].coord_idx)[ii]*relweight;
++
++                SK_P(points->p[atmp].coord_idx)[ii] = ftmp;
++            }
++            points->p[points->p[i].assign].weight += points->p[i].weight;
++        }
++    }
++
++    return 0;
+ }
+ 
+ /* copy centers from points to centers */
+ void copycenters(Points *points, Points* centers, long* centerIDs, long offset)
+ {
+-  long i;
+-  long k;
++    long i;
++    long k;
++
++    bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));
++
++    /* mark the centers */
++    for ( i = 0; i < points->num; i++ ) {
++        is_a_median[points->p[i].assign] = 1;
++    }
+ 
+-  bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));
++    k=centers->num;
+ 
+-  /* mark the centers */
+-  for ( i = 0; i < points->num; i++ ) {
+-    is_a_median[points->p[i].assign] = 1;
+-  }
++    /* count how many  */
++    for ( i = 0; i < points->num; i++ ) {
++        if ( is_a_median[i] ) {
+ 
+-  k=centers->num;
++            // XXX write
+ 
+-  /* count how many  */
+-  for ( i = 0; i < points->num; i++ ) {
+-    if ( is_a_median[i] ) {
+-      memcpy( centers->p[k].coord, points->p[i].coord, points->dim * sizeof(float));
+-      centers->p[k].weight = points->p[i].weight;
+-      centerIDs[k] = i + offset;
+-      k++;
++            memcpy(centers->p[k].coord,
++                    SK_P(points->p[i].coord_idx), points->dim * sizeof(float));
++
++            centers->p[k].weight = points->p[i].weight;
++            centerIDs[k] = i + offset;
++            k++;
++        }
+     }
+-  }
+ 
+-  centers->num = k;
++    centers->num = k;
+ 
+-  free(is_a_median);
++    free(is_a_median);
+ }
+ 
+ struct pkmedian_arg_t
+ {
+-  Points* points;
+-  long kmin;
+-  long kmax;
+-  long* kfinal;
+-  int pid;
+-  pthread_barrier_t* barrier;
++    Points* points;
++    long kmin;
++    long kmax;
++    long* kfinal;
++    int pid;
++    bool indirection;
++    pthread_barrier_t* barrier;
+ };
+ 
+ void* localSearchSub(void* arg_) {
+ 
+-  pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;
+-  pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);
++    pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;
+ 
+-  return NULL;
+-}
++#ifdef SC_REPLICATION
++    if (arg->indirection) {
++        //    printf("Thread %2d using replica %2d\n", arg->pid, replica_lookup[arg->pid]);
++        sk_block_a = sk_block_accessors[replica_lookup[arg->pid]];
++    } else {
++        sk_block_a = sk_center_org;
++    }
++#endif
++
++#ifdef SK_BIND
++#ifdef ENABLE_THREADS
++    shl__bind_processor_aff(arg->pid);
++#endif
++#endif
+ 
+-#ifdef TBB_VERSION
+-void localSearch( Points* points, long kmin, long kmax, long* kfinal ) {
+-  pkmedian_arg_t arg;
+-  arg.points = points;
+-  arg.kmin = kmin;
+-  arg.kmax = kmax;
+-  arg.pid = 0;
+-  arg.kfinal = kfinal;
+-  localSearchSub(&arg);
++    shl__init_thread(arg->pid);
++
++    pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);
++
++    return NULL;
+ }
+-#else //!TBB_VERSION
+ 
+-void localSearch( Points* points, long kmin, long kmax, long* kfinal ) {
++void localSearch( Points* points, long kmin, long kmax, long* kfinal, bool use_indirection ) {
+     pthread_barrier_t barrier;
+     pthread_t* threads = new pthread_t[nproc];
+     pkmedian_arg_t* arg = new pkmedian_arg_t[nproc];
+ 
++    papi_start();
+ #ifdef ENABLE_THREADS
+     pthread_barrier_init(&barrier,NULL,nproc);
+ #endif
+     for( int i = 0; i < nproc; i++ ) {
+-      arg[i].points = points;
+-      arg[i].kmin = kmin;
+-      arg[i].kmax = kmax;
+-      arg[i].pid = i;
+-      arg[i].kfinal = kfinal;
++        arg[i].points = points;
++        arg[i].kmin = kmin;
++        arg[i].kmax = kmax;
++        arg[i].pid = i;
++        arg[i].kfinal = kfinal;
++        arg[i].indirection = use_indirection;
+ 
+-      arg[i].barrier = &barrier;
++        arg[i].barrier = &barrier;
+ #ifdef ENABLE_THREADS
+-      pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);
++        pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);
+ #else
+-      localSearchSub(&arg[0]);
++        localSearchSub(&arg[0]);
+ #endif
+     }
+ 
+ #ifdef ENABLE_THREADS
+     for ( int i = 0; i < nproc; i++) {
+-      pthread_join(threads[i],NULL);
++        pthread_join(threads[i],NULL);
+     }
+ #endif
++    papi_stop();
+ 
+     delete[] threads;
+     delete[] arg;
+@@ -1742,302 +967,369 @@ void localSearch( Points* points, long k
+     pthread_barrier_destroy(&barrier);
+ #endif
+ }
+-#endif // TBB_VERSION
+-
+ 
+ class PStream {
+ public:
+-  virtual size_t read( float* dest, int dim, int num ) = 0;
+-  virtual int ferror() = 0;
+-  virtual int feof() = 0;
+-  virtual ~PStream() {
+-  }
++    virtual size_t read( float* dest, int dim, int num ) = 0;
++    virtual int ferror() = 0;
++    virtual int feof() = 0;
++    virtual ~PStream() {
++    }
+ };
+ 
+ //synthetic stream
+ class SimStream : public PStream {
+ public:
+-  SimStream(long n_ ) {
+-    n = n_;
+-  }
+-  size_t read( float* dest, int dim, int num ) {
+-    size_t count = 0;
+-    for( int i = 0; i < num && n > 0; i++ ) {
+-      for( int k = 0; k < dim; k++ ) {
+-	dest[i*dim + k] = lrand48()/(float)INT_MAX;
+-      }
+-      n--;
+-      count++;
+-    }
+-    return count;
+-  }
+-  int ferror() {
+-    return 0;
+-  }
+-  int feof() {
+-    return n <= 0;
+-  }
+-  ~SimStream() { 
+-  }
++
++#ifdef SK_CRC_INPUT
++    crc_t crc;
++    FILE *fp;
++    const char* inputf;
++#endif
++    SimStream(long n_ ) {
++        n = n_;
++        printf("Generating points randomly .. \n");
++#ifdef SK_WRITE_INPUT
++        inputf = "/tmp/sc_input_native";
++        printf("Opening input file to write random coord [%s]\n", inputf);
++        fp = fopen(inputf, "wb");
++#endif
++#ifdef SK_CRC_INPUT
++        crc = crc_init();
++#endif
++    }
++    size_t read( float* dest, int dim, int num ) {
++        size_t count = 0;
++        for( int i = 0; i < num && n > 0; i++ ) {
++            for( int k = 0; k < dim; k++ ) {
++                dest[i*dim + k] = lrand48()/(float)INT_MAX;
++            }
++            n--;
++            count++;
++        }
++#ifdef SK_WRITE_INPUT
++        std::fwrite(dest, sizeof(float)*dim, num, fp);
++#endif
++#ifdef SK_CRC_INPUT
++        crc = crc_update(crc, (unsigned char*) dest, sizeof(float)*dim*num);
++#endif
++        return count;
++    }
++    int ferror() {
++        return 0;
++    }
++    int feof() {
++        return n <= 0;
++    }
++    ~SimStream() {
++#ifdef SK_CRC_INPUT
++        crc = crc_finalize(crc);
++        printf("0x%lx\n", (unsigned long)crc);
++#endif
++#ifdef SK_WRITE_INPUT
++        fclose(fp);
++#endif
++    }
+ private:
+-  long n;
++    long n;
+ };
+ 
+ class FileStream : public PStream {
+ public:
+-  FileStream(char* filename) {
+-    fp = fopen( filename, "rb");
+-    if( fp == NULL ) {
+-      fprintf(stderr,"error opening file %s\n.",filename);
+-      exit(1);
+-    }
+-  }
+-  size_t read( float* dest, int dim, int num ) {
+-    return std::fread(dest, sizeof(float)*dim, num, fp); 
+-  }
+-  int ferror() {
+-    return std::ferror(fp);
+-  }
+-  int feof() {
+-    return std::feof(fp);
+-  }
+-  ~FileStream() {
+-    fprintf(stderr,"closing file stream\n");
+-    fclose(fp);
+-  }
++#ifdef SK_CRC_INPUT
++    crc_t crc;
++#endif
++    FileStream(char* filename) {
++
++        printf("Reading points from file\n");
++
++#ifdef SK_CRC_INPUT
++        crc = crc_init();
++#endif
++        fp = fopen( filename, "rb");
++        if( fp == NULL ) {
++            fprintf(stderr,"error opening file %s\n.",filename);
++            exit(1);
++        }
++    }
++    size_t read( float* dest, int dim, int num ) {
++        size_t res = std::fread(dest, sizeof(float)*dim, num, fp);
++#ifdef SK_CRC_INPUT
++        crc = crc_update(crc, (unsigned char*) dest, sizeof(float)*dim*num);
++#endif
++        return res;
++    }
++    int ferror() {
++        return std::ferror(fp);
++    }
++    int feof() {
++        return std::feof(fp);
++    }
++    ~FileStream() {
++        fprintf(stderr,"closing file stream\n");
++#ifdef SK_CRC_INPUT
++        crc = crc_finalize(crc);
++        printf("0x%lx\n", (unsigned long)crc);
++#endif
++        fclose(fp);
++    }
+ private:
+-  FILE* fp;
++    FILE* fp;
+ };
+ 
+ void outcenterIDs( Points* centers, long* centerIDs, char* outfile ) {
+-  FILE* fp = fopen(outfile, "w");
+-  if( fp==NULL ) {
+-    fprintf(stderr, "error opening %s\n",outfile);
+-    exit(1);
+-  }
+-  int* is_a_median = (int*)calloc( sizeof(int), centers->num );
+-  for( int i =0 ; i< centers->num; i++ ) {
+-    is_a_median[centers->p[i].assign] = 1;
+-  }
+-
+-  for( int i = 0; i < centers->num; i++ ) {
+-    if( is_a_median[i] ) {
+-      fprintf(fp, "%u\n", centerIDs[i]);
+-      fprintf(fp, "%lf\n", centers->p[i].weight);
+-      for( int k = 0; k < centers->dim; k++ ) {
+-	fprintf(fp, "%lf ", centers->p[i].coord[k]);
+-      }
+-      fprintf(fp,"\n\n");
++    FILE* fp = fopen(outfile, "w");
++    if( fp==NULL ) {
++        fprintf(stderr, "error opening %s\n",outfile);
++        exit(1);
++    }
++    int* is_a_median = (int*)calloc( sizeof(int), centers->num );
++    for( int i =0 ; i< centers->num; i++ ) {
++        is_a_median[centers->p[i].assign] = 1;
++    }
++
++    for( int i = 0; i < centers->num; i++ ) {
++        if( is_a_median[i] ) {
++            fprintf(fp, "%lu\n", centerIDs[i]);
++            fprintf(fp, "%lf\n", centers->p[i].weight);
++            for( int k = 0; k < centers->dim; k++ ) {
++                // This only works on the master array, as updates are only done there
++                fprintf(fp, "%lf ", centers->p[i].coord[k]);
++            }
++            fprintf(fp,"\n\n");
++        }
+     }
+-  }
+-  fclose(fp);
++    fclose(fp);
+ }
+ 
+-void streamCluster( PStream* stream, 
+-		    long kmin, long kmax, int dim,
+-		    long chunksize, long centersize, char* outfile )
++void streamCluster( PStream* stream,
++                    long kmin, long kmax, int dim,
++                    long chunksize, long centersize, char* outfile )
+ {
++    float* block = (float*)malloc( chunksize*dim*sizeof(float) );
++    float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );
++    long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));
++
++    if( block == NULL ) {
++        fprintf(stderr,"not enough memory for a chunk!\n");
++        exit(1);
++    }
+ 
+-#ifdef TBB_VERSION
+-  float* block = (float*)memoryFloat.allocate( chunksize*dim*sizeof(float) );
+-  float* centerBlock = (float*)memoryFloat.allocate(centersize*dim*sizeof(float) );
+-  long* centerIDs = (long*)memoryLong.allocate(centersize*dim*sizeof(long));
+-#else
+-  float* block = (float*)malloc( chunksize*dim*sizeof(float) );
+-  float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );
+-  long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));
+-#endif
+-
+-  if( block == NULL ) { 
+-    fprintf(stderr,"not enough memory for a chunk!\n");
+-    exit(1);
+-  }
+-
+-  Points points;
+-  points.dim = dim;
+-  points.num = chunksize;
+-  points.p = 
+-#ifdef TBB_VERSION
+-    (Point *)memoryPoint.allocate(chunksize*sizeof(Point), NULL);
+-#else
++    Points points;
++    points.dim = dim;
++    points.num = chunksize;
++    points.p =
+     (Point *)malloc(chunksize*sizeof(Point));
+-#endif
+-
+-  for( int i = 0; i < chunksize; i++ ) {
+-    points.p[i].coord = &block[i*dim];
+-  }
+-
+-  Points centers;
+-  centers.dim = dim;
+-  centers.p = 
+-#ifdef TBB_VERSION
+-    (Point *)memoryPoint.allocate(centersize*sizeof(Point), NULL);
+-#else
+-    (Point *)malloc(centersize*sizeof(Point));
+-#endif
+-  centers.num = 0;
+-
+-  for( int i = 0; i< centersize; i++ ) {
+-    centers.p[i].coord = &centerBlock[i*dim];
+-    centers.p[i].weight = 1.0;
+-  }
+ 
+-  long IDoffset = 0;
+-  long kfinal;
+-  while(1) {
+-
+-    size_t numRead  = stream->read(block, dim, chunksize ); 
+-    fprintf(stderr,"read %d points\n",numRead);
+-
+-    if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {
+-      fprintf(stderr, "error reading data!\n");
+-      exit(1);
++    // Set accessors
++    sk_block_a = block;
++    sk_center_org = centerBlock;
++    sk_block_org = block;
++
++    for( int i = 0; i < chunksize; i++ ) {
++        points.p[i].coord = &block[i*dim];
++        points.p[i].coord_idx = i*dim;
+     }
+ 
+-    points.num = numRead;
+-    for( int i = 0; i < points.num; i++ ) {
+-      points.p[i].weight = 1.0;
+-    }
+-
+-#ifdef TBB_VERSION
+-    switch_membership = (bool*)memoryBool.allocate(points.num*sizeof(bool), NULL);
+-    is_center = (bool*)calloc(points.num,sizeof(bool));
+-    center_table = (int*)memoryInt.allocate(points.num*sizeof(int));
+-#else
+-    switch_membership = (bool*)malloc(points.num*sizeof(bool));
+-    is_center = (bool*)calloc(points.num,sizeof(bool));
+-    center_table = (int*)malloc(points.num*sizeof(int));
+-#endif
+-
+-
+-    //fprintf(stderr,"center_table = 0x%08x\n",(int)center_table);
+-    //fprintf(stderr,"is_center = 0x%08x\n",(int)is_center);
+-
+-    localSearch(&points,kmin, kmax,&kfinal); // parallel
++    Points centers;
++    centers.dim = dim;
++    centers.p =
++    (Point *)malloc(centersize*sizeof(Point));
++    centers.num = 0;
+ 
+-    //fprintf(stderr,"finish local search\n");
+-    contcenters(&points); /* sequential */
+-    if( kfinal + centers.num > centersize ) {
+-      //here we don't handle the situation where # of centers gets too large. 
+-      fprintf(stderr,"oops! no more space for centers\n");
+-      exit(1);
++    for( int i = 0; i< centersize; i++ ) {
++        centers.p[i].coord = &centerBlock[i*dim];
++        centers.p[i].coord_idx = i*dim;
++        centers.p[i].weight = 1.0;
+     }
+ 
+-    copycenters(&points, &centers, centerIDs, IDoffset); /* sequential */
+-    IDoffset += numRead;
++    int skit = 0;
+ 
+-#ifdef TBB_VERSION
+-    memoryBool.deallocate(switch_membership, sizeof(bool));
+-    free(is_center);
+-    memoryInt.deallocate(center_table, sizeof(int));
+-#else
+-    free(is_center);
+-    free(switch_membership);
+-    free(center_table);
+-#endif
++    long IDoffset = 0;
++    long kfinal;
++    while(1) {
+ 
+-    if( stream->feof() ) {
+-      break;
+-    }
+-  }
++        size_t numRead  = stream->read(block, dim, chunksize );
++        fprintf(stderr,"read %zu points\n",numRead);
+ 
+-  //finally cluster all temp centers
+-#ifdef TBB_VERSION
+-  switch_membership = (bool*)memoryBool.allocate(centers.num*sizeof(bool));
+-  is_center = (bool*)calloc(centers.num,sizeof(bool));
+-  center_table = (int*)memoryInt.allocate(centers.num*sizeof(int));
+-#else
+-  switch_membership = (bool*)malloc(centers.num*sizeof(bool));
+-  is_center = (bool*)calloc(centers.num,sizeof(bool));
+-  center_table = (int*)malloc(centers.num*sizeof(int));
+-#endif
++        int pagesize = -1;
+ 
+-  localSearch( &centers, kmin, kmax ,&kfinal ); // parallel
+-  contcenters(&centers);
+-  outcenterIDs( &centers, centerIDs, outfile);
++#ifdef SC_REPLICATION
++        int num_replicas = -1;
++        int malloc_options = SHL_MALLOC_NONE;
++#ifdef SC_HUGEPAGE
++        malloc_options |= SHL_MALLOC_HUGEPAGE;
++#endif
++        assert(num_replicas<=0);
++        sk_block_accessors =
++            (float**) shl__malloc_replicated(chunksize*dim*sizeof(float),
++                                             &pagesize,
++                                             &num_replicas,
++                                             malloc_options, NULL);
++
++        printf("shl__repl_sync NOW .. \n");
++        shl__repl_sync(block, (void**) sk_block_accessors,
++                       num_replicas, chunksize*dim*sizeof(float));
++#endif
++
++        if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {
++            fprintf(stderr, "error reading data!\n");
++            exit(1);
++        }
++
++        // SK: fix: if no more points are read, abort
++        if (stream->feof() && numRead==0) {
++            fprintf(stderr, "no more points, aborting\n");
++            break;
++        }
++
++        points.num = numRead;
++        for( int i = 0; i < points.num; i++ ) {
++            points.p[i].weight = 1.0;
++        }
++
++        switch_membership = (bool*)malloc(points.num*sizeof(bool));
++        is_center = (bool*)calloc(points.num,sizeof(bool));
++        center_table = (int*)malloc(points.num*sizeof(int));
++
++        // Using points -> indirection
++        localSearch(&points, kmin, kmax,&kfinal, true); // parallel
++
++        //fprintf(stderr,"finish local search\n");
++        sk_block_a = sk_block_org; contcenters(&points); /* sequential */
++        if( kfinal + centers.num > centersize ) {
++            //here we don't handle the situation where # of centers gets too large.
++            fprintf(stderr,"oops! no more space for centers\n");
++            exit(1);
++        }
++
++        copycenters(&points, &centers, centerIDs, IDoffset); /* sequential */
++        IDoffset += numRead;
++
++        free(is_center);
++        free(switch_membership);
++        free(center_table);
++
++#ifdef SK_CRC_RUNTIME
++        // Print CRC for both, centers and blocks:
++        crc_t crc_b, crc_c;
++        crc_b = crc_init(); crc_c = crc_init();
++        crc_b = crc_update(crc_b, (unsigned char*) block, chunksize*dim*sizeof(float));
++        crc_c = crc_update(crc_c, (unsigned char*) centerBlock, centersize*dim*sizeof(float));
++        crc_b = crc_finalize(crc_b); crc_c = crc_finalize(crc_c);
++        printf("Iteration %d: centers=0x%lx points=0x%lx\n", skit++, crc_c, crc_b);
++#endif /* SK_CRC_RUNTIME */
++
++        if( stream->feof() ) {
++            break;
++        }
++
++    }
++
++    //finally cluster all temp centers
++    switch_membership = (bool*)malloc(centers.num*sizeof(bool));
++    is_center = (bool*)calloc(centers.num,sizeof(bool));
++    center_table = (int*)malloc(centers.num*sizeof(int));
++
++    printf("localSearch .. \n");
++    // using centers -> NO indirection
++    localSearch( &centers, kmin, kmax ,&kfinal, false ); // parallel
++    printf("contcenters .. \n");
++    sk_block_a = sk_center_org; contcenters(&centers);
++    printf("outcenterIDs .. \n");
++    outcenterIDs( &centers, centerIDs, outfile);
++
++#ifdef SK_CRC_RUNTIME
++    // Print CRC for both, centers and blocks:
++    crc_t crc_b, crc_c;
++    crc_b = crc_init(); crc_c = crc_init();
++    crc_b = crc_update(crc_b, (unsigned char*) block, chunksize*dim*sizeof(float));
++    crc_c = crc_update(crc_c, (unsigned char*) centerBlock, centersize*dim*sizeof(float));
++    crc_b = crc_finalize(crc_b); crc_c = crc_finalize(crc_c);
++    printf("Iteration %d: centers=0x%lx points=0x%lx\n", skit++, crc_c, crc_b);
++#endif /* SK_CRC_RUNTIME */
+ }
+ 
+ int main(int argc, char **argv)
+ {
+-  char *outfilename = new char[MAXNAMESIZE];
+-  char *infilename = new char[MAXNAMESIZE];
+-  long kmin, kmax, n, chunksize, clustersize;
+-  int dim;
++    assert (sizeof(uintptr_t)==8);
++
++    char *outfilename = new char[MAXNAMESIZE];
++    char *infilename = new char[MAXNAMESIZE];
++    long kmin, kmax, n, chunksize, clustersize;
++    int dim;
+ 
+ #ifdef PARSEC_VERSION
+ #define __PARSEC_STRING(x) #x
+ #define __PARSEC_XSTRING(x) __PARSEC_STRING(x)
+-        fprintf(stderr,"PARSEC Benchmark Suite Version "__PARSEC_XSTRING(PARSEC_VERSION)"\n");
++    fprintf(stderr,"PARSEC Benchmark Suite Version "__PARSEC_XSTRING(PARSEC_VERSION)"\n");
+ 	fflush(NULL);
+ #else
+-        fprintf(stderr,"PARSEC Benchmark Suite\n");
++    fprintf(stderr,"PARSEC Benchmark Suite\n");
+ 	fflush(NULL);
+ #endif //PARSEC_VERSION
+ #ifdef ENABLE_PARSEC_HOOKS
+-  __parsec_bench_begin(__parsec_streamcluster);
++    __parsec_bench_begin(__parsec_streamcluster);
+ #endif
+ 
+-  if (argc<10) {
+-    fprintf(stderr,"usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n",
+-	    argv[0]);
+-    fprintf(stderr,"  k1:          Min. number of centers allowed\n");
+-    fprintf(stderr,"  k2:          Max. number of centers allowed\n");
+-    fprintf(stderr,"  d:           Dimension of each data point\n");
+-    fprintf(stderr,"  n:           Number of data points\n");
+-    fprintf(stderr,"  chunksize:   Number of data points to handle per step\n");
+-    fprintf(stderr,"  clustersize: Maximum number of intermediate centers\n");
+-    fprintf(stderr,"  infile:      Input file (if n<=0)\n");
+-    fprintf(stderr,"  outfile:     Output file\n");
+-    fprintf(stderr,"  nproc:       Number of threads to use\n");
+-    fprintf(stderr,"\n");
+-    fprintf(stderr, "if n > 0, points will be randomly generated instead of reading from infile.\n");
+-    exit(1);
+-  }
+-
+-
+-
+-  kmin = atoi(argv[1]);
+-  kmax = atoi(argv[2]);
+-  dim = atoi(argv[3]);
+-  n = atoi(argv[4]);
+-  chunksize = atoi(argv[5]);
+-  clustersize = atoi(argv[6]);
+-  strcpy(infilename, argv[7]);
+-  strcpy(outfilename, argv[8]);
+-  nproc = atoi(argv[9]);
+-
+-
+-#ifdef TBB_VERSION
+-  fprintf(stderr,"TBB version. Number of divisions: %d\n",NUM_DIVISIONS);
+-  tbb::task_scheduler_init init(nproc);
+-#endif
+-
+-
+-  srand48(SEED);
+-  PStream* stream;
+-  if( n > 0 ) {
+-    stream = new SimStream(n);
+-  }
+-  else {
+-    stream = new FileStream(infilename);
+-  }
++    // Input for native:
++    // 10 20 - 128 0 - 200000 5000
+ 
++    if (argc<10) {
++        fprintf(stderr,"usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n",
++                argv[0]);
++        fprintf(stderr,"  k1:          Min. number of centers allowed\n");
++        fprintf(stderr,"  k2:          Max. number of centers allowed\n");
++        fprintf(stderr,"  d:           Dimension of each data point\n");
++        fprintf(stderr,"  n:           Number of data points\n");
++        fprintf(stderr,"  chunksize:   Number of data points to handle per step\n");
++        fprintf(stderr,"  clustersize: Maximum number of intermediate centers\n");
++        fprintf(stderr,"  infile:      Input file (if n<=0)\n");
++        fprintf(stderr,"  outfile:     Output file\n");
++        fprintf(stderr,"  nproc:       Number of threads to use\n");
++        fprintf(stderr,"\n");
++        fprintf(stderr, "if n > 0, points will be randomly generated instead of reading from infile.\n");
++        exit(1);
++    }
++
++    kmin = atoi(argv[1]);
++    kmax = atoi(argv[2]);
++    dim = atoi(argv[3]);
++    n = atoi(argv[4]);
++    chunksize = atoi(argv[5]);
++    clustersize = atoi(argv[6]);
++    strcpy(infilename, argv[7]);
++    strcpy(outfilename, argv[8]);
++    nproc = atoi(argv[9]);
++
++    shl__init(nproc,false);
++
++    srand48(SEED);
++    PStream* stream;
++    if( n > 0 ) {
++        stream = new SimStream(n);
++    }
++    else {
++        stream = new FileStream(infilename);
++    }
+ 
+ #ifdef ENABLE_PARSEC_HOOKS
+-  __parsec_roi_begin();
++    __parsec_roi_begin();
+ #endif
+ 
+-  streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );
++    shl__start_timer(0);
++    streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );
++    printf("Runtime: %f\n", shl__end_timer("runtime"));
+ 
+ #ifdef ENABLE_PARSEC_HOOKS
+-  __parsec_roi_end();
++    __parsec_roi_end();
+ #endif
+ 
+-  delete stream;
++    delete stream;
+ 
+ #ifdef ENABLE_PARSEC_HOOKS
+-  __parsec_bench_end();
++    __parsec_bench_end();
+ #endif
+-  
+-  return 0;
++
++    return 0;
+ }
